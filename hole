#!/usr/bin/env python
#coding: utf8

import sys

sys.setrecursionlimit(60*60)

DEBUG = False
MODE = -1
if len(sys.argv)>1:
    for a in sys.argv[1:]:
        if a == "-d":
            DEBUG = True
        elif a == "--ascii":
            MODE = 0
        elif a == "--unicode":
            MODE = 1
        elif a == "--standalone":
            MODE = 2
        else:
            print("Unrecognized option: "+a)
            exit()
        

def sgn(x):
    if x == 0:
        return 0
    if x > 0:
        return 1
    else:
        return -1
def reverse(lis):
    return lis[::-1]
def goodstring(st):
    if len(st)>16:
        return st[:14]+".."
    else:
        return st.ljust(16)




def get_line(x1, y1, x2, y2):
    #from http://roguebasin.roguelikedevelopment.org/index.php?title=Bresenham%27s_Line_Algorithm
    points = []
    issteep = abs(y2-y1) > abs(x2-x1)
    if issteep:
        x1, y1 = y1, x1
        x2, y2 = y2, x2
    rev = False
    if x1 > x2:
        x1, x2 = x2, x1
        y1, y2 = y2, y1
        rev = True
    deltax = x2 - x1
    deltay = abs(y2-y1)
    error = int(deltax // 2)
    y = y1
    ystep = None
    if y1 < y2:
        ystep = 1
    else:
        ystep = -1
    for x in range(x1, x2 + 1):
        if issteep:
            points.append((y, x))
        else:
            points.append((x, y))
        error -= deltay
        if error < 0:
            y += ystep
            error += deltax
    # Reverse the list if the coordinates were reversed
    if rev:
        points.reverse()
    return points


from random import randint

try:
    from dMap import *
except ImportError:
    print("could not find the crucial file dMap.py. Are you running from *inside* the hole directory?")


try:
    import curses
    havecurses = True
except ImportError:
    print("curses library not found. Starting in standalone mode...")
    havecurses = False

if havecurses:
    stdscr = curses.initscr()
    curses.start_color()
    curses.use_default_colors()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(1)
    curses.curs_set(0)

    (WY,WX) = stdscr.getmaxyx()

    while WX<67 or WY<26:
        (WY,WX) = stdscr.getmaxyx()

        stdscr.addstr(0,0,"SCREEN SIZE INSUFFICIENT. PLEASE RESIZE.")
        flush_main()
else:
    MODE = 2

if MODE == -1:
    stdscr.clear()
    MODE = 0
    while True:
        for i in range(0,3):
            stdscr.addstr(1+i,1,">"*(i==MODE) + ["ASCII","UNICODE","STANDALONE/GRAPHICAL"][i] + "   ")
    
        stdscr.addstr(5 ,1,"Unicode and Graphical mode are experimental.  ")
        stdscr.addstr(6 ,1,"Unicode mode extends the available characters,")
        stdscr.addstr(7 ,1,"for an interesting experience. Graphical opens")
        stdscr.addstr(8 ,1,"a standalone window. Unicode needs Python 3.3;")
        stdscr.addstr(9 ,1,"Graphical needs the pygame module.            ")
        stdscr.addstr(10 ,1,"       ")

        stdscr.addstr(12,1,"P.S.: you can avoid this prompt by appending ")
        stdscr.addstr(13,1,"the --ascii, --unicode or --standalone options")
        stdscr.refresh()
        s=stdscr.getch()
        if s == curses.KEY_UP:
            MODE = (MODE - 1)%3
        if s == curses.KEY_DOWN:
            MODE = (MODE + 1)%3
        if s == ord('\n'):
            break

if MODE == 1:
    UNICODE = 1
else:
    UNICODE = 0

if MODE == 2:
    GRAPHIC = 1
else:
    GRAPHIC = 0

if UNICODE:
    import locale
    locale.setlocale(locale.LC_ALL,"")

#starting graphics.py (pygame) for graphic mode
if GRAPHIC:
    if havecurses:
        curses.nocbreak()
        stdscr.keypad(0)
        curses.echo()
        curses.endwin()

    try:
        import graphics
    except ImportError:
        print("Unable to import graphics.py. Are you running from the hole directory?")
        exit()
    term = graphics.Terminal(67,26,"Pastiche_16x16.png")

    stdscr = term.stdscr

graphcolors = [(0,1)]*20

if GRAPHIC:
    KEYUP = graphics.KUP
    KEYDOWN = graphics.KDOWN
    KEYLEFT = graphics.KLEFT
    KEYRIGHT = graphics.KRIGHT
    KEYENTER = graphics.KENTER
else:
    KEYUP = curses.KEY_UP
    KEYDOWN = curses.KEY_DOWN
    KEYLEFT = curses.KEY_LEFT
    KEYRIGHT = curses.KEY_RIGHT
    KEYENTER = ord('\n')

 
'''
def stdscr.addch(y,x,char,col=0):
    if GRAPHIC:
        libtcod.console_put_char(0,x,y,char, libtcod.BKGND_SET)
        
    else:
        stdscr.addch(y,x,char,col)

def stdscr.addstr(y,x,string,col=0):
    if GRAPHIC:
#        libtcod.console_set_default_foreground(0, graphcolors[col][0])
#        libtcod.console_set_default_background(0, graphcolors[col][1])
        libtcod.console_print(0,x,y, string)
    else:
        stdscr.addstr(y,x,string,col)



def flush_main():
    if GRAPHIC:
        libtcod.console_flush()
    else:
        stdscr.refresh()'''

def getchar():
    if GRAPHIC:
        return term.getch()
    else:
        return stdscr.getch()

def flush_main():
    if GRAPHIC:
        term.refresh()
    else:
        stdscr.refresh()

def blitlvl():
    global camx,camy,mypad,term
    if GRAPHIC:
        term.blit(mypad,camy,camx,1,1,LW_H+1,LW_W+1)
    else:
        mypad.noutrefresh(camy,camx,1,1,LW_H+1,LW_W+1)

def blitback():
    global back
    if GRAPHIC:
        term.blit(back,0,0,0,0,26,67)
    else:
        back.noutrefresh()

BXCHARS =   ['+','+','+','+','|','-','+','+','+','+']
if UNICODE:
    BXCHARS = [curses.ACS_ULCORNER,curses.ACS_URCORNER,curses.ACS_LLCORNER,curses.ACS_LRCORNER,curses.ACS_VLINE,curses.ACS_HLINE,curses.ACS_TTEE,curses.ACS_BTEE,curses.ACS_RTEE,curses.ACS_LTEE]

'''
╔═╦═╗╓─╥─╖╒═╤═╕┌─┬─┐
║ ║ ║║ ║ ║│ │ ││ │ │
╠═╬═╣╟─╫─╢╞═╪═╡├─┼─┤
║ ║ ║║ ║ ║│ │ ││ │ │
╚═╩═╝╙─╨─╜╘═╧═╛└─┴─┘
'''

WALLS = [
    ( '#',1),(u'═',1),(u'║',1),(u'╚',1),
    (u'═',1),(u'═',1),(u'╝',1),(u'╩',1),
    (u'║',1),(u'╔',1),(u'║',1),(u'╠',1),
    (u'╗',1),(u'╦',1),(u'╣',1),(u'╬',1) ]



#DATA

dtypenames = ["Dungeon","Gnome Village","The End"]

classnames = [ "MIND", "BODY", "LIGHT" , "ABORT"]

tfile = open('title','r')
title = tfile.readlines()
tfile.close()

vfile = open('vending','r')
vendingback = vfile.readlines()
vfile.close()

cfile = open('credits','r')
creditsdata = cfile.readlines()
credits = creditsdata[:24]
creditsred = creditsdata[24:49]
creditsyellow = creditsdata[49:75]
cfile.close()

def color_pair(n):
    global GRAPHIC
    if GRAPHIC:
        return n
    else:
        return curses.color_pair(n)


def addstrtrans(screen,y,x,string,col = color_pair(0)):
    for i in range(0,len(string)):
        if string[i] != ' ':
            screen.addch(y,x+i,string[i],col)

def isfree(num):
    return (num in [0])
def isnonsolid(num):
    return (num in [0,8])


#OBJECT STRUCTURE:
# [0] x / null in inv
# [1] y / null in inv
# [2] id
# [3] adj
# [4] plant type
# [5] clear

MAXMANA = 300
MAXINV = 19
INVCLIP = 20

OBJ_GOLD  = 0
OBJ_PLANT = 1
OBJ_BREAD = 2
OBJ_DROP = 3
OBJ_EMERALD = 4
OBJ_GOULASH = 5
OBJ_FAIRY_LIVER = 6
OBJ_PASTA = 7
OBJ_CHESTMONSTER = 8
OBJ_STONE = 9
OBJ_STRAMONIUM_SEED = 10
OBJ_HANDBOOK = 11
OBJ_CARCASS = 12
OBJ_PUKE = 13
OBJ_GNOME = 14

OBJ_BOOK_BOTANY = 100
OBJ_BOOK_TELEPORTATION = 101
OBJ_BOOK_FIRE = 102
OBJ_BOOK_THUNDER = 103
OBJ_BOOK_GEOGRAPHY = 104
OBJ_BOOK_TRANSMIGRATION = 105
MAXBOOK = 105

OBJ_SWORD = 200
OBJ_GLOVES = 201
OBJ_SHIELD = 202
OBJ_WAND = 203
MAXARMOUR = 203

OBJ_DRAGON_SCALES = 225

OBJ_SWORD_GOLDEN = 250
OBJ_SHIELD_GOLDEN = 251
MAXGOLDEN = 251

OBJ_LETTER = 900
OBJ_PAPER = 901

guidetopic = {
0:"Gold can be used to buy items in Gift Shops.",
1:"ERROR",
2:"Restores 25 HP",
3:"Gives 1 Mana point"
}

def object_names(obj):
    num = obj[2]
    out="ERROR"
    matr= {
    0:"Gold Nugget",
    1:"Plant_DEBUG",
    2:"Bread",
    3:"Mana Drop",
    4:"Emerald",
    5:"Goulash",
    6:"Fairy Liver",
    7:"Pasta",
    8:"CHESTMONSTER_DEBUG",
    9:"Stone",
    10:"Stramonium Seed",
    11:"Magic Handbook",
    12:"Carcass_DEBUG",
    13:"Puke",
    14:"Gnome",
    
    100:"Book of Botany",
    101:"Book of Teleportation",
    102:"Book of Fire",
    103:"Book of Thunder",
    104:"Book of Geography",
    105:"Book of Transmigration",

    200:"Sword",
    201:"Gloves",
    202:"Shield",
    203:"Magic Wand",

    225:"Dragon Scales",

    250:"Golden Sword"+DEBUG*"0123456789",
    251:"Golden Shield",

    900:"Letter",
    901:"Piece of Paper"
    }
    if num in matr:
        out=matr[num]
    if num == 1:
        if len(obj)>=6 and obj[5] == 1:
            if obj[3] == 0:
                out = plants[obj[4]]
            else:
                out = plant_adjectives[obj[3]][1] + " " + plants[obj[4]]
        else:
            out = "Herb"
    if num == OBJ_CARCASS:
        out = mobsalphabet[obj[3]] + " Carcass" 

    if num == OBJ_CHESTMONSTER and len(obj)>=5:
        out = object_names([0,0,obj[4]])
    
    if num == OBJ_GNOME:
        out = obj[3].name

    return out


plant_adjectives = {
0:(0.5,"PLAIN"),
1:(0.7,"Stinging"),
2:(0.8,"Sacred"),
3:(0.9,"Spicy"),
4:(1,"Silver"),
5:(0.95,"Golden")
}

plants = {
0:("Basil"),
1:("Stramonium"),
2:("Sage"),
3:("Nettle"),
4:("Dandelion")
}

solids = []


# name / sprite / attack / defense / hp / exp

mobsalphabet = {
0:"Ant",
1:"Bee",
2:"Chicken",
3:"Dog",
4:"Emu",
5:"Frog",
6:"Gerbil",
7:"Hyena",
8:"Impala",
9:"Jackal",
10:"Kangaroo",
11:"Leech",
12:"Moth",
13:"Nabarlek",
14:"Ostrich",
15:"Penguin",
16:"Quetzal",
17:"Rabbit",
18:"Squid",
19:"Tiger",
20:"Uakari",
21:"Vulture",
22:"Wolf",
23:"Xanclomys",
24:"Yak",
25:"Zebra"}

animalsymbols = [chr(ord('a')+i) for i in range(0,len(mobsalphabet))]
if UNICODE:
    animalsymbols[0] = u'¥'
    animalsymbols[1] = u'ഴ'
    animalsymbols[5] = u'ൠ'
    animalsymbols[18] = u'ᴥ'
    



                                               #atk            #dfn                #hp         #exp
mobs = [[mobsalphabet[i] , animalsymbols[i],  2 + max(i,-25+3*i), max(1,i-1,-24+3*i), 4+2*(i+i*i//4),  i//2+1] for i in range(0,len(mobsalphabet))]

freezinganimals = [x + ord('a') for x in ( [8,13,15,16,18,21,23,25] + [0,1]*DEBUG) ] + ['I']

bosses = {
    "Dragon":   ["Dragon",  'D', 150, 80, 1000,300],
    "Fairy":    ["Fairy" ,  'F', 4 , 18,  70, 100],
    "Ice Troll":    ["Ice Troll",   'I', 100, 60, 350, 300],
    "Succubus" :    ["Succubus",    'S', 18, 10, 120, 5 ],
    "Gnome":    ["Gnome",   'g']
}

if UNICODE:
    bosses["Succubus"][1] = u'☿'

DR_SLEEPING = 0
DR_AWAKE = 1
DR_ANGRY = 2

DR_IDLE = 0
DR_CHARGING = 1
DR_FIRING = 2

class dragonBrain:
    def __init__(self):
        self.status = randint(0,2)//2
        self.charge = DR_IDLE
        self.bx = 0
        self.by = 0
        self.particles = 0

gnomenames = "Berenbur Minnimalkin Bimpni Minnizig Boddywinkle Murkor Bunkkor Nacklebell Cobbnab Namji Dalfoodle Namzig Duvabert Ninbert Duvakor Pilwinkle Elmadge Ranzbert Folmalkin Ranzmut Fudwick Ranznor Garder Roywinkle Glimtwiss Schepgel Hedbiddle Schepmalkin Jebkor Shamip Klemmut Turkor Klemto Wayfoodle Lindtwiss Waypest Looppen Wayrick Loopwyn Zookmadge Lumbiddle Zookmottin Lumwinkle Zooknock Mibbini Zookpen Minnibur Zookwinkle Minnijon".split(" ")

GN_HIDING = 0
GN_EMPTY = 1
GN_FULL = 2
GN_DONE = 3

class gnomeBrain:
    def __init__(self):
        self.status = GN_HIDING

class gnomeStuff:
    def __init__(self):
        self.name = choice(gnomenames)
        self.loot = -1


'''mobs = {
0:("Worm"   ,'w',1,0,5 ,2),
1:("Frog"   ,'f',1,1,8 ,3),
2:("Moth"   ,'m',2,0,10,3),
3:("Squid"  ,'s',2,2,11,5),
4:("Leech"  ,'l',3,2,14,7),
5:("Rabbit" ,'r',4,3,16,9),
6:("Zombie" ,'z',5,2,19,11),
7:("Tiger"  ,'t',8,4,22,13),
8:("Ghost"  ,'g',7,6,24,14)
}'''

LV_W=60
LV_H=60
LW_W=40
LW_H=15

converter = {
0:0,
1:2,
2:1,
3:3,
4:3,
5:3,

55:11,

66:8,

98:6,
99:5
}

converter2 = {
0:0,
1:2,
2:12,
3:3,
4:3,
5:3,
55:11,
66:8,
98:6,
99:5
}

#TILESET and SPRITESHEET
tset = {
0: (' ',0), #walkable empty tile
1: ('#',1), #wall
2: (' ',0), #unexplored/outside
3: ('=',5), #door
4: ('v',0), #exit
5: ('#',7), #golden wall
6: ('X',7), #golden column
7: ('$',9), #gift shop
8: ('~',12),    #lava
9: ('*',2), #emerald walkway
10: ('.',0),    #emerald walkway (not activated)
11: ('$',1),    #dirt
12: ('%',5),    #wood

100: ('~',6),   #water
101: ('@',10)   #Oskar
}

if UNICODE:
    tset[100] = (u'♒',6)

ssheet = {
0: ('*',3),
1: ('Y',2),
2: ('0',3),
3: ('*',8),
4: ('*',2),
5: ('Q',3),
6: ('&',2),
7: ('%',3),
8: ('C',4),
9: ('o',0),
10:('.',2),
11:('=',10),
12:('E',0),
13:('8',2),
14:('E',2),

100: ('?',2),
101: ('?',3),
102: ('?',4),
103: ('?',3),
104: ('?',3),
105: ('?',10),

200: ('!',0),
201: (':',0),
202: ('O',0),
203: ('\\',0),

225: ('"',18),

250: ('!',3),
251: ('O',3),

900: ('l',0),
901: ('4',0)
}

if UNICODE:
    ssheet[1] = (u'⚶',2)

SPELL_FIRE = 0
SPELL_TELEPORT = 1
SPELL_SUICIDE = 2
SPELL_HEAL = 3
SPELL_GOLDEN = 4
SPELL_WATCH = 5
SPELL_SHOCKWAVE = 6
SPELL_THUNDER = 7
SPELL_TRANSMIGRATION = 8
SPELL_WINTER = 9

EL_FIRE = 0
EL_THUNDER = 1
EL_ICE = 2

def addchsafe(y,x,char,color):
    if(y in range(0,LV_H-1)):
        if x in range(0,LV_W-1):
            mypad.addch(y,x,char,color)

def elemental(t):
    global orientation
    if randint(0,3)==0:
    #   if DEBUG:
            #mess("DEBUG elemental of type "+str(t))
        oldor = [orientation[0],orientation[1]]
        if t==0:
            s=[ (-1,0) , (0,-1) ]
        elif t==1:
            s=[ (1,0) , (1,-1) ]
        elif t==2:
            s=[ (0,1) , (-1,1) ]

        d = choice(s)

        if DEBUG:
            mess("Step: "+str(d))
    
        orientation[0] += d[0]
        orientation[1] += d[1]
        if(orientation[0]+orientation[1]>4) or (not orientation[0] in range(0,5)) or (not orientation[1] in range(0,5)):
            if DEBUG:
                mess("OUT. "+str(oldor))
            orientation = [oldor[0],oldor[1]]

        if DEBUG:
            mess("orientation: " + str(orientation[0])+str(orientation[1]))

spellbook = [
[       [3,SPELL_TELEPORT,"Teleport"],      [2,SPELL_HEAL,"Heal"],      [3,SPELL_TRANSMIGRATION,"Transmigr."]   ],
[       [2,SPELL_SHOCKWAVE,"Shockwave"],    [4,SPELL_FIRE,"Fire"],      [6,SPELL_WINTER,"Winter"]       ],
[       [2,SPELL_THUNDER,"Thunder"],        [2,SPELL_WATCH,"Clairv."]                       ]
]

def spellrange(n):
    wand = 0
    for k in equip:
        if k[0][2]==OBJ_WAND:
            wand = 1
    diddly = {
        SPELL_THUNDER:8,
        SPELL_SHOCKWAVE:5,
        SPELL_FIRE:5,
        SPELL_WATCH:5*(wand==0) - (wand==1),
        SPELL_TRANSMIGRATION: (3 + 4*wand)
    }
    if n in diddly:
        return diddly[n]
    else:
        return -1

def spellcast(n):
    global entities, x, y, mxhp, hp, stage, waterfrozen, clairvoying
    wand = 0
    for k in equip:
        if k[0][2]==OBJ_WAND:
            wand = 1

    if n==0: #fire spell
        mess("You cast a Fire Spell")
        elemental(EL_FIRE)
        count = 0
        for e in entities:
            if e[0] in range(x-5,x+6) and e[1] in range(y-5,y+6):
                hite(e,8*(1+wand) + atk//2  )
                count +=1
        if count>0:
            mess(str(count)+" enemies got burned by your spell")
        else:
            mess("... but there is noone to hurt.")
    elif n==1: #teleport
        elemental(1)
        if stage < 50:
            (x,y)=findfree()
            mess("You teleport somewhere else")
        else:
            mess("Surprisingly, you are unable to teleport...")
    elif n==2: #miscast
        hitp(60,True)
        mess("You miscast and hurt yourself (-60 HP)")
    elif n==3: #healing
        elemental(EL_ICE)
        s=(20 + randint(0,30*wand))*mxhp//100
        hp = min(mxhp,hp+s)
        mess("You cast a healing spell (+"+str(s)+" HP)")
    elif n==4: #coins
        s=randint(20,50)
        for i in range(0,s):
            xm = randint(x-4,x+5)
            ym = randint(y-4,y+5)
            if isfreepos(xm,ym):
                objects.append([xm,ym,OBJ_GOLD])
        mess("You make a large amount of coins materialize")
    elif n==5: #clairvoyance
        elemental(EL_THUNDER)
        if wand == 0:
            for i in range(max(0,x-5),min(x+6,LV_W-1)):
                for j in range(max(0,y-5),min(y+6,LV_H-1)):
                    floodfill(i,j)
        else:
            for i in range(0,LV_W):
                for j in range(0,LV_H):
                    floodfill(i,j)
        clairvoying = 1 + wand

        mess("You cast a clairvoyance spell.")

        for b in objects:
            if b[2] == OBJ_CHESTMONSTER and (abs(x-b[0])+abs(y-b[1]) < 15 ):
                b[3] = 1
                mess("A trap was revealed.")

    elif n==6: #shockwave
        mess("You cast a Shockwave Spell")
        count = 0
        for e in entities:
            if e[0] in range(x-5,x+6) and e[1] in range(y-5,y+6):
                nx = max(min(e[0]+randint(2,5+3*wand)*sgn(e[0]-x),LV_W-1),0)
                ny = max(min(e[1]+randint(2,5+3*wand)*sgn(e[1]-y),LV_H-1),0)
                if isnonsolid(lvl[nx][ny]):
                    e[0]=nx
                    e[1]=ny
                    count+=1
                else:
                    if randint(0,2) == 0:
                        hite(e,int((3 + atk//2)*(1+0.5*wand)))
                        count+=1
        if count>0:
            mess(str(count)+" enemies were affected by the wave")
        else:
            mess("... but there is noone to hurt.")

    elif n==7: # thunder spell
        count = []
        leclos = 100
        for i in range(0,len(entities)):
            e = entities[i]
            if (e[0] in range(x-8,x+9)) and (e[1] in range(y-8,y+9)) and (cansee(x,y,e[0],e[1])):
                count.append(i)

                        
        if len(count)>0:
            i = 0
            stdscr.addstr(0,3,"CHOOSE TARGET FOR THUNDER",color_pair(10))
            rays = [get_line(x,y,entities[e][0],entities[e][1]) for e in count]
            while True:
                for j in range(0,len(count)):
                    if j == i:
                        rcol = (' ',color_pair(16))
                    else:
                        rcol = ('.',color_pair(4))
                    for k in rays[j]:
                        mypad.addch(k[1],k[0],rcol[0],rcol[1])
                for j in range(0,len(count)):
                    e = entities[count[j]]
                    if j == i:
                        rcol = (' ',color_pair(16))
                    else:
                        rcol = ('.',color_pair(4))
                    mypad.addch(e[1],e[0],e[3],rcol[1])

                mypad.addch(y,x,'@',color_pair(16))

                blitlvl()
                flush_main()
                s = getchar()
                
                if s == KEYLEFT:
                    i=(i-1)%len(count)
                elif s == KEYRIGHT:
                    i=(i+1)%len(count)
                elif s == KEYENTER:
                    break

            #0 3 10

            tget = count[i]
            mess("You cast a Thunder Spell on the "+entities[tget][2]+str(leclos))
            hite(entities[tget],int((3+atk//2)*(1+wand)))

        else:
            mess("You cast a Thunder Spell that goes nowhere")      
#   elif n==7:
#       count = []
#       for e in entities:
#           if e[0] in range(x-8,x+9) and e[1] in range(y-8,y+9):
#               count.append(e)

#       tget = 

#       mess("You cast a Thunder Spell")
    
    elif n==8: #transmigration
        elemental(EL_THUNDER)
        trange = 3+4*wand
        stdscr.addstr(0,3,"CHOOSE DIRECTION FOR TRANSMIGRATION",color_pair(10))
        count = 0
        dc = -1
        while True:
            draw()
            mypad.addch(y,x,'@',color_pair(10))  
            '''for i in range(1,trange+1):
                addchsafe(y,x-i,' ',color_pair(13))
                addchsafe(y,x+i,' ',color_pair(13))
                addchsafe(y-i,x,' ',color_pair(13))
                addchsafe(y+i,x,' ',color_pair(13))
            for i in range(1,count+1):
            for i in range(1,count+1):
                if dc == 2:
                    addchsafe(y,x-i,' ',color_pair(14))
                if dc == 0:
                    addchsafe(y,x+i,' ',color_pair(14))
                if dc == 3:
                    addchsafe(y-i,x,' ',color_pair(14))
                if dc == 1:
                    addchsafe(y+i,x,' ',color_pair(14))    '''

            i = count
            if dc == 2:
                    addchsafe(y,x-i,'@',color_pair(2))
            if dc == 0:
                    addchsafe(y,x+i,'@',color_pair(2))
            if dc == 3:
                    addchsafe(y-i,x,'@',color_pair(2))
            if dc == 1:
                    addchsafe(y+i,x,'@',color_pair(2))
            

            blitlvl()
            flush_main()
            ccc = getchar()    
            if ccc == KEYDOWN:
                if dc != 1:
                    count = 0
                else:
                    count += 1
                dc = 1
            if ccc == KEYLEFT:
                if dc != 2:
                    count = 0
                else:
                    count+=1
                dc = 2
            if ccc == KEYUP:
                if dc != 3:
                    count = 0
                else:
                    count+=1
                dc = 3
            if ccc == KEYRIGHT:
                if dc != 0:
                    count = 0
                else:
                    count+=1
                dc = 0

            count = min(count,trange)
            if ccc == KEYENTER:
                dc = max(dc,0)
                break
        dirs = [ (1,0) , (0,1) , (-1,0), (0,-1) ]
        x += dirs[dc][0] * count
        y += dirs[dc][1] * count
        
        mess("You cast a Transmigration Spell")

        if (not isnonsolid(lvl[x][y])) or (lvl[x][y]==2):
            hp = 0
            mess("You fragged yourself.")

        for e in entities:
            if e[0] == x and e[1] == y:
                mess("You frag the "+e[2]+" (-50HP)")
                mess("You frag yourself (-50% HP)")
                hite(e,50)
                hitp(hp//2,True)

        #10 13 14   
    elif n == 9:
        mess("You cast a Winter Spell")
        mess("The whole dungeon becomes very cold...")
        waterfrozen = True
        for c in range(0, randint(1,3)):
            (gx,gy) = findfree()
            entities.append([gx,gy]+bosses["Ice Troll"])

CURS_ICE = 0
CURS_POISON = 1
CURS_LOVE = 2
MAXCURS = 2

curses_names = {
    CURS_ICE:"Frozen",
    CURS_POISON:"Poisoned",
    CURS_LOVE:"In Love"
}

curses_initial = ["F","P","L"]

curses_colors = {
    CURS_ICE:8,
    CURS_POISON:2,
    CURS_LOVE:4
}
    
catalogue = [
    [50,1,[0,0,OBJ_BOOK_BOTANY]],
    [40,1,[0,0,OBJ_BOOK_GEOGRAPHY]],
    [80,1,[0,0,OBJ_PLANT,5,0,1]],
    [100,1,[0,0,OBJ_PLANT,5,2,1]],
    [30,1,[0,0,OBJ_WAND]],      
    [70,1,[0,0,OBJ_SWORD_GOLDEN]]

]   
                        

#ATTRIBUTES
ATTRPOINTS = 2

ATTR_HAWK_EYE = 0
ATTR_STRONG_HANDS = 1
ATTR_DRAGONBORN = 2
ATTR_PIOUS = 3

attribute_strings = {
    ATTR_HAWK_EYE:("Hawk Eye","Extends the field of vision."),
    ATTR_STRONG_HANDS:("Strong Hands","Lowers probability of losing items in battle, increases probability of catching gnomes"),
    ATTR_DRAGONBORN:("Dragonborn","Half damage with lava"),
    ATTR_PIOUS:("Pious","Mana drops always yield +2")
    }

def exprofile(r):
    return int(r*4.9 + r*r*4.9//16)

if havecurses:
    curses.init_pair(0, curses.COLOR_WHITE,     curses.COLOR_BLACK)
    curses.init_pair(1, curses.COLOR_BLACK,     curses.COLOR_WHITE)     #1 black on white
    curses.init_pair(2, curses.COLOR_GREEN,     curses.COLOR_BLACK)     #2 green
    curses.init_pair(3, curses.COLOR_YELLOW,    curses.COLOR_BLACK)     #3 yellow
    curses.init_pair(4, curses.COLOR_RED,       curses.COLOR_BLACK)     #4 red
    curses.init_pair(5, curses.COLOR_BLACK,     curses.COLOR_YELLOW)    #5 black on yellow
    curses.init_pair(6, curses.COLOR_WHITE,     curses.COLOR_BLUE)  #white on blue
    curses.init_pair(7, curses.COLOR_YELLOW,    curses.COLOR_WHITE)     #yellow on white
    curses.init_pair(8, curses.COLOR_BLUE,      curses.COLOR_BLACK)     #blue on black
    curses.init_pair(9, curses.COLOR_WHITE,     curses.COLOR_RED)   #white on red
    curses.init_pair(10,curses.COLOR_MAGENTA,   curses.COLOR_BLACK)     #magenta
    curses.init_pair(11,curses.COLOR_WHITE,     curses.COLOR_YELLOW)    #white on yellow
    curses.init_pair(12,curses.COLOR_YELLOW,    curses.COLOR_RED)   #yellow on red
    curses.init_pair(13,curses.COLOR_BLACK,     curses.COLOR_MAGENTA)   #black on magenta
    curses.init_pair(14,curses.COLOR_MAGENTA,   curses.COLOR_GREEN) #magenta on green
    curses.init_pair(15,curses.COLOR_WHITE, curses.COLOR_BLUE)  #white on blue
    curses.init_pair(16,curses.COLOR_BLUE,  curses.COLOR_YELLOW)    #blue on yellow
    curses.init_pair(17,curses.COLOR_BLACK, -1)         #test
    curses.init_pair(18,curses.COLOR_CYAN,  curses.COLOR_BLACK) #cyan


C_WHITE = color_pair(1)
C_WHITERED = color_pair(9)
C_WHITEYELLOW = color_pair(11)
C_WHITEBLUE = color_pair(6)

if GRAPHIC:
    mypad = graphics.Pad(LV_W,LV_H) 
    back = graphics.Pad(67,26)
else:
    mypad = curses.newpad(LV_W,LV_H)
    back = curses.newwin(0,0)

flush_main()


#INIT
mxhp=100
hp=100
mana=0
manacount=0
gold=0
rank=1
gems=[False]*50
slaindragons=0
exp=0
waterfrozen=False
curss = [0]*(MAXCURS+1)
spellsprog = [1,0,0] 
if DEBUG:
   curss = [10,0,0]
orientation = choice([ [1,2] , [2,1] , [1,1] ])
ID = randint(0,999999999)

specialending = -1

name="ERROR"
dungeonname = choice ( [ "Ala", "Seth", "More", "Dath", "Kathra"]) + choice ( [ "go", "na" , "ka", "gu", "ni"]) + choice ( [ "r", "r", "dor"])
DEBUG_CHEST = [[0,0,OBJ_HANDBOOK], [0,0,OBJ_PAPER,1]  ,[0,0,OBJ_WAND], [0,0,OBJ_STONE], [0,0,OBJ_PLANT,0,1,1] , [0,0,OBJ_STONE], [0,0,OBJ_CARCASS,7] ]
inventory = [ [0,0,OBJ_BREAD] , [0,0,OBJ_LETTER] ] #+ DEBUG_CHEST 
if DEBUG: inventory+= DEBUG_CHEST
equip = [ ]

dialogue0 = [
(0,"I am {0}, I was sent from the King".format(name)),
(0,"I am here to murder you, Oskar."),
(1,"I salute you, {0}.".format(name)),
(1,"I'm a little confused here, though."),
(1,"Because I was sent myself from His Majesty the King"),
(1,"To slay Aradach, the Spider Goddess, and free these tunnels from the Darkness"),
(1,"And annex them to the Reign"),
(0,"That's preposterous. Why would the King send me to murder his own knight?"),
(0,"Certainly you must be lying."),
(1,"Or you must be."),
(0,"I have a letter signed from the King himself."),
(1,"Can I take a look at that? I'm sure any murder can wait.")
]

dialogue1 = [
(0,"I... uhmm... I seem to have dropped it somewhere..."),
(1,"How convenient."),
(0,"I swear I had it from me..."),
(1,"This is the most vile of all the tricks Aradach has tried on me"),
(1,"A ghost, an image with the appearance of a warrior of the King."),
(1,"What I am about to do comes to me with the sweetest pleasure."),
(2,"Oskar stabs you."),
(2,"He moves the knife about in your stomach"),
(2,"You start bleeding uncontrollably."),
(1,"CAN YOU HEAR ME, ARADACH? I WILL HAVE YOUR HEAD, FOR THE KING!"),
(2,"You collapse. Everything goes dark.")
]

dialogue2 = [
(0,"Sure, here it is."),
(1,"Well, isn't this awkward..."),
(1,"This IS the signature of the King."),
(1,"...clearly someone is having a big fat laugh at us."),
(0,"So yeah, let me guess..."),
(1,"...there is no Spider Goddess..."),
(0,"...and no Dark Mage."),
(1,"There's just a knight who knows a bit to much..."),
(0,"...a dissident warrior he wants to get rid of..."),
(1,"...and a convenient system of caves, stuffed with holy emeralds"),
(1,"but also hostile creatures, which are expensive to eradicate."),
(1,"We are the cleaners to his emerald cave."),
(1,"I've been here a long time, searching for Aradach,"),
(1,"recognizing his eight-eyed grin in every shadow"),
(1,"and I was just slaving for the King"),
(1,"performing the duty of a peasant."),
(0,"We don't have much time. The dungeon is being quickly flooded."),
(1,"Oh."),
(0,"Oh what?"),
(1,"We are dead."),
(1,"The King has decided to drown us."),
(0,"You are quite the downer, you know that?"),
(1,"I'm quite the realist."),
(0,"I have an idea... but it's a shot in the dark."),
(2,"You hear the rumble of water entering the last floor..."),
(1,"Spare me the preamble and just try to save us."),
(2,"You cast a Teleportation Spell.")
]

#help panel
helppanel = [
"                                                                   ",
" ?             open this panel                                     ",
" ARROW KEYS    movement/attack                                     ",
" u             use object from inventory (eat, equip, etc...)      ",
" d             drop object from inventory/equipment                ",
" i             info panel                                          ",
" c             cast spell                                          ",
" a             pick up item (right where you are)                  ",
" s             skip turn                                           ",
" v             toggle FOV dots (the annoying blue m*********ers)   ",
" p             commit suicide (yes, you'll need this.)             ",
" q             see messages history (arrow keys to navigate)       ",
" z             sort inventory alphabetically                       ",
"                                                                   "

]


#clues
clues = [
[
"                                                     ",
"      .-.---.,--.----,......     ,.---------------.  ",
"   ,.'warrior. We thought i'.-...- be extremely   |  ",
"  |   nice if you descended through the dark      |  ",
"   >  rooms of the deep dungeon of "+dungeonname.ljust(11) + "   <   ",
"  |   where --..--....,,-...dach, Queen of Sp.--.-'  ",
"   '-----'---''            '-----.-----.----'        "],

[
".---------------------------------------.",
"| An easy, tasty recipe!                |",
"| Ingredients:                          |",
"| * A meaty stramonium plant            |",
"| * a rock                              |",
"|     Difficuly: Easy                   |",
"|                                       |",
"| Smash the Stramonium with the stone.  |",
"| You're done!                          |",
"|                                       |",
"| Guaranteed to B L O W your mind!      |",
"`---------------------------------------'"
]
]


def finale():
    global name, inventory, OBJ_LETTER, alive, specialending
    hasletter = False
    for c in inventory:
        if c[2] == OBJ_LETTER:
            hasletter = True
    diag = dialogue0 + dialogue1
    if hasletter:
        diag = dialogue0 + dialogue2
        
    for l in diag:
        stdscr.clear()
        stdscr.addch(15,20,'@',color_pair(10))   
        stdscr.addch(15,23,'@',color_pair(0))
        stdscr.addstr(7,6,"                                             ")
        n = [name+": ","Oskar: ",""][l[0]]
        dcl = [color_pair(i) for i in [8,10,0]][l[0]]
        s1 = (n+l[1])[:50]
        s2 = ""
        if len(n+l[1])>50:
            s2 = (n+l[1])[50:]
        stdscr.addstr(7,6,s1,dcl)
        stdscr.addstr(8,6+len(n),s2,dcl)
        if l[0] == 2:
            mess(s1)
        #curses.napms(100)
        getchar()

    alive = False 
    if not hasletter:
        specialending = 0
    else:
        if sum(gems)>=40:
            specialending = 2
        else:
            mess("When you reach the surface, you are arrested")
            mess("by the guards of the king, and hanged.")
            specialending = 1
        

def additem(o):
    if len(inventory)<MAXINV:
        inventory.append(o)
        return True
    else:
        return False

atk=1
dfn=0



objects = []
entities = []

def hitp(force,ignoredef=False):
    global hp, dfn, equip
    if ignoredef:
        damage = force
    else:
        shield = 0
        for k in equip:
            if k[0][2] == OBJ_SHIELD:
                shield = 2
        for k in equip:
            if k[0][2] == OBJ_SHIELD_GOLDEN:
                shield = 4
        damage = force - randint(0,dfn+shield)
    damage = max(0,damage)
    hp=max(0,hp-damage)
    return damage

def dropshit(x,y,lv):
    global objects
    if lvl[x][y]!=8:
        value = randint(0,lv)
        lo = [0]
        if value <= 1:
            lo = [OBJ_GOLD]
        elif value <= 3:
            lo = ranplant()
        elif value <= 5:
            lo = [OBJ_HANDBOOK]
        elif value <= 6:
            lo = [choice(range(100,MAXBOOK))]
        elif value <= 9:
            lo = [choice(range(200,MAXARMOUR))]
        elif value <= 12:
            lo = [choice(range(250,MAXGOLDEN))]
        else:
            lo = [OBJ_GOLD]
        objects.append([x,y]+lo)

def hite(e,force):
    global slaindragons
    if e[2] == "Gnome":
        return
    damage = max(0,force-randint(0,e[5]))
    e[6] = max(0,e[6]-force)
    if(e[6]<=0):
        mess("The "+e[2]+" is dead.")
        if (e[3] in range(ord('a'),ord('z')+1)):
            if randint(0,5)==0:
                dropshit(e[0],e[1],e[3]-ord('a'))
            elif randint(0,8)==0:
                #dropcarcass
                objects.append([e[0],e[1], OBJ_CARCASS, e[3] - ord('a')])
        if (e[2] == "Fairy"):
            if lvl[x][y]!=8:
                objects.append([e[0],e[1],OBJ_FAIRY_LIVER])
        if (e[2] == "Dragon"):
            if lvl[x][y]!=8:
                objects.append([e[0],e[1],OBJ_DRAGON_SCALES])
            slaindragons += 1
                
        entities.remove(e)
        givexp(e[7])
    else:
        if(damage>0):
            mess("The "+e[2]+" was hit. (-"+str(damage)+" HP)")
        else:
            mess("You missed the "+e[2])

        if (e[2] == "Dragon"):
            if e[8].status == DR_SLEEPING:
                e[8].status = DR_ANGRY
                mess("You awake and anger the Dragon.")
            if e[8].status == DR_AWAKE:
                e[8].status = DR_ANGRY
                mess("The Dragon is angered")


def givexp(amt):
    global exp, rank, atk, dfn, mxhp, hp
    exp += amt
    lepl = False
    while(exp >= exprofile(rank)):
        exp-=exprofile(rank)
        rank+=1
        atk += (1 + rank//10)*(not gender) + (min(randint(0,3),1) + rank//10)*gender
        dfn+=(rank+3)//7
        oldhp = mxhp
        mxhp+=3 + rank**2//17
        hp = (hp*mxhp)//oldhp
        lepl=True
    if(lepl):
        mess("Welcome to level "+str(rank))

def iswall(cx,cy):
    if((cx<0)or(cy<0)or(cx>=LV_W)or(cy>=LV_H)):
        return False
    if fog[cx][cy] == 0:
        return False
    return lvl[cx][cy] in [1,3,5,11]
 

def isfreepos(cx,cy):
    if((cx<0)or(cy<0)or(cx>=LV_W)or(cy>=LV_H)):
        return False
    s = True
    global x,y

    if ((x==cx) and(y==cy)):
        s = False
    for e in entities:
        if ((e[0]==cx) and(e[1]==cy)):
            s = False
    for o in objects:
        if ((o[2]) in solids):
            if ((o[0]==cx)and(o[1]==cy)):
                s = False

    return (s and isfree(lvl[cx][cy]))

def iswalkable(cx,cy):
    if((cx<0)or(cy<0)or(cx>=LV_W)or(cy>=LV_H)):
        return False
    s = True
    global x,y

    if ((x==cx) and(y==cy)):
        s = False
    for e in entities:
        if ((e[0]==cx) and(e[1]==cy)):
            s = False
    for o in objects:
        if ((o[2]) in solids):
            if ((o[0]==cx)and(o[1]==cy)):
                s = False

    return (s and isnonsolid(lvl[cx][cy]))

def isfrees(qx,qy):
    return isfree(lvl[qx][qy])

def ispathable(num):
    return (num in [0,3,8])

'''def cansee(xa,ya,xb,yb):
    x1=min(xa,xb)
    x2=max(xa,xb)
    y1=min(ya,yb)
    y2=max(ya,yb)
    clear1=True
    for x in range(x1,x2+1):
        clear1 = clear1 and isnonsolid(lvl[x][y1])
    for y in range(y1,y2+1):
        clear1 = clear1 and isnonsolid(lvl[x2][y])

    clear2=True
    for y in range(y1,y2+1):
        clear2 = clear2 and isnonsolid(lvl[x1][y])
    for x in range(x1,x2+1):
        clear2 = clear2 and isnonsolid(lvl[x][y2])
    
    return clear1 or clear2 '''

def cansee(xa,ya,xb,yb):
    if (xa==xb) and (ya==yb):
        return True
    s = True
    for sp in get_line(xa,ya,xb,yb):
        if not (sp in [(xa,ya),(xb,yb)]): 
            if not isnonsolid(lvl[sp[0]][sp[1]]):
                return False
    return True


messages=[("the adventure begins",0)]
def mess(strin,col=0):
    if False: #len(messages)>=5:
        messages.pop(0)
    messages.append([strin,col])

def findfree():
    global lvl
    gx = 0
    gy = 0
    safe = 0
    while not isfree(lvl[gx][gy]) and safe < 400:
        gx = randint(0,LV_W-1)
        gy = randint(0,LV_H-1)
        safe+=1
    return (gx,gy)

fog = []
def floodfill(xs,ys,ite=-1,force=False):
    if (xs < 0) or (xs>=LV_W) or (ys < 0) or (ys>=LV_H):
        return
    if ite==0:
        return
    if ite==-1:
        nex=-1
    else:
        nex=ite-1
    
    if fog[xs][ys] != 0 and not force:
        return
    fog[xs][ys] = 1
    if isnonsolid(lvl[xs][ys]):
        floodfill(xs+1,ys,nex)
        floodfill(xs-1,ys,nex)
        floodfill(xs,ys-1,nex)
        floodfill(xs,ys+1,nex)
        floodfill(xs+1,ys+1,nex)
        floodfill(xs-1,ys+1,nex)
        floodfill(xs-1,ys-1,nex)
        floodfill(xs+1,ys-1,nex)

con = []
def confloodfill(xs,ys,ite=-1):
    global con
    if (xs < 0) or (xs>=LV_W) or (ys < 0) or (ys>=LV_H):
        return
    if ite==0:
        return
    if ite==-1:
        nex=-1
    else:
        nex=ite-1
    
    if con[xs][ys] != 0:
        return
    con[xs][ys] = 1
    if ispathable(lvl[xs][ys]):
        confloodfill(xs+1,ys,nex)
        confloodfill(xs-1,ys,nex)
        confloodfill(xs,ys-1,nex)
        confloodfill(xs,ys+1,nex)
        confloodfill(xs+1,ys+1,nex)
        confloodfill(xs-1,ys+1,nex)
        confloodfill(xs-1,ys-1,nex)
        confloodfill(xs+1,ys-1,nex)


def fag(xp,yp):
    global x,y
    return fog[xp][yp]# ( (xp in range(x-4,x+4)) and (yp in range(y-4,y+4)))

FOV_RADIUS = 10

dungeon =  ["###########################################################",
            "#...........#.............................................#",
            "#...........#........#....................................#",
            "#.....................#...................................#",
            "#....####..............#..................................#",
            "#.......#.......................#####################.....#",
            "#.......#...........................................#.....#",
            "#.......#...........##..............................#.....#",
            "#####........#......##..........##################..#.....#",
            "#...#...........................#................#..#.....#",
            "#...#............#..............#................#..#.....#",
            "#...............................#..###############..#.....#",
            "#...............................#...................#.....#",
            "#...............................#...................#.....#",
            "#...............................#####################.....#",
            "#.........................................................#",
            "#.........................................................#",
            "###########################################################"]

class Map(object):
    # Multipliers for transforming coordinates to other octants:
    mult = [
                [1,  0,  0, -1, -1,  0,  0,  1],
                [0,  1, -1,  0,  0, -1,  1,  0],
                [0,  1,  1,  0,  0, -1, -1,  0],
                [1,  0,  0,  1, -1,  0,  0, -1]
            ]
    def __init__(self):
        global LV_W,LV_H
        self.width, self.height = LV_W,LV_H
        self.light = []
        for i in range(self.height):
            self.light.append([0] * self.width)
        self.flag = 0
    def square(self, x, y):
        global lvl
        return lvl[x][y]
    def blocked(self, x, y):
        global lvl
        return (x < 0 or y < 0
                or x >= self.width or y >= self.height
                or not isnonsolid(lvl[x][y]))
    def lit(self, cx, cy):
        global fow,x,y,lvl,clairvoying,attributes

        if clairvoying == 1:
         if (cx-x)**2 + (cy-y)**2 <= (20)**2:
             return True
         else:
            return False
        elif clairvoying == 2:
            return True

        return self.light[cy][cx] == self.flag
    def set_lit(self, x, y):
        if 0 <= x < self.width and 0 <= y < self.height:
            self.light[y][x] = self.flag
    def _cast_light(self, cx, cy, row, start, end, radius, xx, xy, yx, yy, id):
        "Recursive lightcasting function"
        if start < end:
            return
        radius_squared = radius*radius
        for j in range(row, radius+1):
            dx, dy = -j-1, -j
            blocked = False
            while dx <= 0:
                dx += 1
                # Translate the dx, dy coordinates into map coordinates:
                X, Y = cx + dx * xx + dy * xy, cy + dx * yx + dy * yy
                # l_slope and r_slope store the slopes of the left and right
                # extremities of the square we're considering:
                l_slope, r_slope = (dx-0.5)/(dy+0.5), (dx+0.5)/(dy-0.5)
                if start < r_slope:
                    continue
                elif end > l_slope:
                    break
                else:
                    # Our light beam is touching this square; light it:
                    if dx*dx + dy*dy < radius_squared:
                        self.set_lit(X, Y)
                    if blocked:
                        # we're scanning a row of blocked squares:
                        if self.blocked(X, Y):
                            new_start = r_slope
                            continue
                        else:
                            blocked = False
                            start = new_start
                    else:
                        if self.blocked(X, Y) and j < radius:
                            # This is a blocking square, start a child scan:
                            blocked = True
                            self._cast_light(cx, cy, j+1, start, l_slope,
                                             radius, xx, xy, yx, yy, id+1)
                            new_start = r_slope
            # Row is scanned; do next row unless last square was blocked:
            if blocked:
                break
    def do_fov(self, x, y, radius):
        "Calculate lit squares from the given location and radius"
        self.flag += 1
        for oct in range(8):
            self._cast_light(x, y, 1, 1.0, 0.0, radius,
                             self.mult[0][oct], self.mult[1][oct],
                             self.mult[2][oct], self.mult[3][oct], 0)

def checkfow(a,b):
    global fow,x,y,lvl,clairvoying,attributes

    if clairvoying == 1:
        if (a-x)**2 + (b-y)**2 <= (20)**2:
            return True
        else:
            return False
    elif clairvoying == 2:
        return True

    if not fag(a,b):
        return False

    if lvl[a][b] == 2:
        return False
    if (a-x)**2 + (b-y)**2 >= (11 + attributes[ATTR_HAWK_EYE]*5)**2-1:
        return False
    else:
        return cansee(x,y,a,b)
    

    if fow[a][b] == 2:
        return 1
    elif fow[a][b] == 1:
        return 0
    else:
        s = True
        for p in get_line(x,y,a,b):
            if isnonsolid(lvl[p[0]][p[1]]):
                fow[p[0]][p[1]] = 2
            else:
                #fow[p[0]][p[1]] = 1
                s = False
                break
        return s

def ranplant():
    r = (0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,3,3,3,3,4,4,5)
    return [OBJ_PLANT,choice(r),randint(0,4),randint(0,3)//3]


dada =[
"Play as default character",
"Create new character",
"Credits",
"Quit"
]

n = 0
menu = True
while menu:
    if DEBUG and GRAPHIC:
        print("Printing menu...")
    stdscr.clear()
    ppp = 3
    for l in title:
        for i in range(0,len(l)):
            ttlc = color_pair(0)
            stdscr.addch(ppp,8+i,l[i],ttlc) 
        ppp+=1

    for i in range(0,len(dada)):
        if n==i:
            sscc = color_pair(1)
            zibi = "*"
        else:
            sscc = color_pair(0)
            zibi = ""
        stdscr.addstr(12+i,7,zibi+dada[i],sscc)

    if DEBUG and GRAPHIC:
        sys.stdout.write("Flushing...")
        sys.stdout.flush()

    flush_main()

    if DEBUG and GRAPHIC:
        sys.stdout.write("getchar()...")
        sys.stdout.flush()


    key = getchar()

    if DEBUG and GRAPHIC:
        sys.stdout.write(str(key))
        sys.stdout.flush()


    if key in [KEYDOWN,ord('j')]:
        n=(n+1)%len(dada)
    elif key in [KEYUP,ord('k')]:
        n=(n-1)%len(dada)
    elif key == KEYENTER:
        if n == 0:
            menu = False
            name = "Sasellor"
            gender = 0
            spellsprog = [1, 0, 0]
            attributes = [1,1,0,0]
        elif n==1:
            
            m = 0
            stuff = [
            "Name",
            "Gender",
            "First Spell",
            "Attributes",
            "Done"
            ]
            cock = True
            gender = 0
            name = ""
            fspell = 0
            attributes = [0] * len(attribute_strings)
            while cock:
                stdscr.clear()
                for j in range(0,len(stuff)):
                    if m == j:
                        cacol = color_pair(1)
                    else:
                        cacol = color_pair(0)
                    stdscr.addstr(1+j,1,stuff[j],cacol)

                stdscr.addstr(1,15,name)
                stdscr.addstr(2,15,["M","F"][gender])
                stdscr.addstr(3,15,spellbook[fspell][0][2])

                i = 0
                for j in range(0,len(attribute_strings)):
                    if attributes[j]:
                        stdscr.addstr(1+i,27," "+attribute_strings[j][0])
                        i+=1


                flush_main()
                keyy = getchar()

                if keyy == KEYDOWN:
                    m=(m+1)%len(stuff)
                elif keyy == KEYUP:
                    m=(m-1)%len(stuff)
                elif keyy == KEYENTER: 
                    if m==len(stuff)-1:
                        spellsprog = [0]*3
                        spellsprog[fspell] = 1
                        menu = False
                        cock = False
                    if m==0:
                        stdscr.addstr(1,15,"_"*10)
                        curses.echo()
                        name = stdscr.getstr(1,15,10)
                        curses.noecho()
                    if m==1:
                        gender = not gender
                    if m==2:
                        fspell = (fspell+1)%3
                    if m==3:
                        g = 0
                        while True:
                            for i in range(0,len(attribute_strings)):
                                if attributes[i]:
                                    cola = color_pair(0)
                                else:
                                    cola = color_pair(8)
                                stdscr.addstr(1+i,27," "+attribute_strings[i][0],cola)
                            stdscr.addch(1+g,27,'*')
                            stdscr.addstr(3+len(attribute_strings),28,str(ATTRPOINTS - sum(attributes)) + " attribute points left.")
                            
                            stdscr.addstr(15,2," "*50)
                            stdscr.addstr(15,2,attribute_strings[g][1])
                            flush_main()
                            zzz = getchar()
                            if zzz == KEYDOWN:
                                g = (g+1)%len(attribute_strings)
                            if zzz == KEYUP:
                                g = (g-1)%len(attribute_strings)
                            if zzz == KEYENTER:
                                attributes[g] = not attributes[g]
                                if sum(attributes) > ATTRPOINTS:
                                    attributes[g] = not attributes[g]
                            if zzz == KEYLEFT:
                                break
                                

        elif n==2:
            stdscr.clear()
            for j in range(0,len(credits)):
                stdscr.addstr(j,0,credits[j])
            for j in range(0,len(creditsred)):
                addstrtrans(stdscr,j,0,creditsred[j],color_pair(4))
            for j in range(0,len(creditsyellow)):
                addstrtrans(stdscr,j,0,creditsyellow[j],color_pair(3))
            #stdscr.addch(3,8,'#',color_pair(1))
            #stdscr.addch(3,10,'#',color_pair(1))
            flush_main()
            getchar()
        elif n==3:
            curses.nocbreak()
            if MODE != 2:
                stdscr.keypad(0)
            curses.echo()
            curses.endwin()
            exit()


            
    
'''stdscr.addstr(12,5,"Input your name (Press Enter for random name):")
flush_main()
curses.echo()
name = stdscr.getstr(14,6,10)
curses.noecho()'''

def draw():
        global lvl,x,y,entities,objects,fow,fog,tset,ssheet,BXCHARS,mana,hp,mxhp,gold,gems,curss,inventory,equip,stage,rank,atk,dfn,attributes

        #DISPLAY / DRAW

        #do fow
        '''fow = [[0]*LV_H]*LV_W

        for i in range(0,LV_W):
            for j in range(0,LV_H):
                fow[i][j] = 0

#       for i in range(x-1,x+2):
#           for j in range(y-1,y+2):
#               fow[i][j] = 2'''

        fovBrain.do_fov(x,y,(11 + attributes[ATTR_HAWK_EYE]*5))
        

        #draw level draw map display level display map
        
        visdotchar = '.'
        if UNICODE:
            visdotchar = u'⋅'


        mypad.erase()
        for i in range(max(0,x-LW_W),min(x+LW_W,LV_W)):
            for j in range(max(0,y-LW_H),min(y+LW_H,LV_H-1)):
                if fag(i,j):
                    tilecol = color_pair(tset[lvl[i][j]][1])
                    if lvl[i][j] == 100 and waterfrozen:    
                        mypad.addch(j,i,'/' , color_pair(15))
                    elif visibility_dots and lvl[i][j] == 0:
                            if fovBrain.lit(i,j):
                                mypad.addstr(j,i,visdotchar,color_pair(8))
                    elif UNICODE and lvl[i][j] == 1:
                        total = iswall(i+1,j) + 2*iswall(i,j-1) + 4*iswall(i-1,j) + 8*iswall(i,j+1)
                        mypad.addstr(j,i,WALLS[total][0].encode('utf-8'),color_pair(WALLS[total][1]))
                    else:
                        mypad.addstr(j,i,tset[lvl[i][j]][0] , tilecol  )
                else:
                    mypad.addch(j,i,' ',color_pair(0))


                #if DEBUG and lvl[i][j] == 0 and not con[i][j] == 1:
                #    mypad.addch(j,i,'+')
        #draw objects
        for o in objects:
            if fog[o[0]][o[1]] and fovBrain.lit(o[0],o[1]):
                    if o[2] == OBJ_CHESTMONSTER and o[3] == 0:
                        mypad.addch(o[1],o[0],ssheet[o[4]][0], color_pair( ssheet[o[4]][1]))
                    elif o[2] == OBJ_CARCASS:
                        mypad.addch(o[1],o[0],chr(ord('a')+o[3]),color_pair(0))
                    else:
                        mypad.addstr(o[1],o[0],ssheet[o[2]][0], color_pair(ssheet[o[2]][1]))  
        
        #draw entities
        for e in entities:
            if e[2] == "Gnome" and (not isnonsolid(lvl[e[0]][e[1]])):
                continue
            if fog[e[0]][e[1]] and fovBrain.lit(e[0],e[1]):
                if lvl[e[0]][e[1]] == 8:
                    c=color_pair(12)
                else:
                    if e[2] == "Gnome":
                        c = color_pair(2)
                    else:
                        c=color_pair(4) 
                mypad.addstr(e[1],e[0],e[3], c)
                if e[2] == "Dragon":
                    if e[8].particles == -1:
                        mypad.addch(e[1]+e[8].by,e[0]+e[8].bx,'~',color_pair(0))
                    elif e[8].particles > 0:
                        for i in range(1,1+e[8].particles):
                            mypad.addch(e[1]+e[8].by*i,e[0]+e[8].bx*i,'*',color_pair(4))

        #draw character
        if lvl[x][y] == 8:
            c=color_pair(9)
        elif curss[CURS_POISON]>0:
            c=color_pair(2)
        elif curss[CURS_LOVE]>0:
            c=color_pair(4)
        elif curss[CURS_ICE]>0:
            c=color_pair(8)
        else:
            c=color_pair(0) 

        mypad.addch(y,x,'@',c)

        clairvoying = False

        #border
        back.erase()
        back.addch(0,0,BXCHARS[0])
        back.addch(0,LW_W+2,BXCHARS[6])
        back.addch(LW_H+2,0,BXCHARS[2])
        for i in range(0,LW_W+1):   
            back.addch(0,i+1,BXCHARS[5])
        for i in range(0,LW_W+1):
            back.addch(LW_H+2,i+1,BXCHARS[5])
        for i in range(0,LW_H+1):
            back.addch(i+1,0,BXCHARS[4])
            back.addch(i+1,LW_W+2,BXCHARS[4])
        for i in range(0,25):
            back.addch(i+1,LW_W+25,BXCHARS[4])
        back.addch(LW_H+2,LW_W+2,BXCHARS[3])
        back.addch(25,LW_W+25,BXCHARS[3])
        if DEBUG:
            back.addstr(0,3,"DEBUG MODE",color_pair(10))

        #info
        back.addstr(LW_H+3,1, "HP "+str(hp)+"/"+str(mxhp))  
        back.addstr(LW_H+3,14, "G "+str(gold), color_pair(3))
        if mana>0:
            back.addstr(LW_H+3,25, "Mana: "+str(mana), color_pair(8))
        if gems[stage-1]:
            back.addstr(LW_H+3,21, "EF!", color_pair(2))
        ct=0
        for m in reverse(messages[-5:]):
            lecol=color_pair(m[1])
            back.addstr(LW_H+6+ct,1, m[0], lecol)
            ct+=1

        back.addstr(LW_H+2,7,"*FLOOR "+str(stage)+" - "+dtypenames[dtype] +"*")

        for i in range(LW_W+3,LW_W+3+22):
            back.addch(0,i,BXCHARS[5])
        back.addch(0,LW_W+3+22, BXCHARS[1])
        back.addstr(1,LW_W+4, name)
        cs = 0
        for c in range(0,len(curss)):
            if curss[c]>0:
                if curss[c] > 9:
                    ster = "+"
                else:
                    ster = str(curss[c])

                back.addstr(1,LW_W+15+cs,ster,color_pair(curses_colors[c]))
                cs+=1

        back.addstr(1,LW_W+19, "LV "+str(rank).zfill(2))
        back.addch(1,LW_W+25,BXCHARS[4])

        for j in range(LW_W+3,LW_W+25):
            back.addch(6,j,BXCHARS[5])
            back.addch(2,j,BXCHARS[5])
        for k in [2,6]:
            back.addch(k,LW_W+2,BXCHARS[9])
            back.addch(k,LW_W+25,BXCHARS[8])
        back.addstr(6,LW_W+2+8, "INVENTORY")
        for i in range(0,len(inventory)):
            s = object_names(inventory[i])[:INVCLIP]

            back.addstr(7+i,LW_W+4, s,color_pair(ssheet[inventory[i][2]][1]))

        back.addstr(2,LW_W+2+8,"EQUIPMT")

        for i in range(0,len(equip)):
            back.addstr(3+i,LW_W+4, object_names(equip[i][0])[:INVCLIP])

        back.addstr(LW_H+4,1,"ATK "+str(atk)+" DEF "+str(dfn))

        if waterlvl >= WATSTEPS:
            back.addstr(LW_H+4,15, "Water to floor "+str(waterlvl//WATSTEPS))


        blitback()
        blitlvl()
    
        flush_main()

def dopturn(cmd):

        global x,y,hp,mxhp,gold,mana,lvl,entities,ssheet,tset,objects,inventory,equip,waterlvl,atk,dfn,stage,rank,attributes,alive,crawlin,visibility_dots

        turn = False

        toosick=False
        if curss[CURS_POISON] == 1:
            toosick=True
            mess("You puke. (-20 HP)",4)
            objects.append([x,y,OBJ_PUKE])
            hitp (20,True)
            return True

        if curss[CURS_POISON] and randint(0,max(0,200-curss[CURS_POISON])//50) == 0:
            toosick=True
            mess("You feel sick and can't move",2)
            return True

        if curss[CURS_ICE] > 0:
            if cmd in [KEYUP,KEYDOWN,KEYLEFT,KEYRIGHT]:
                if randint(0,1):
                    mess("Way too cold. Not doing that.")
                else:
                    mess("You're frozen, so there's that.")
                return False

        if curss[CURS_ICE] <= 0 and not toosick:
            nx = x
            ny = y
            hasmoved = 0
            if  cmd in [KEYDOWN,ord('j')]:
                ny = min(y+1,LV_H-2)
                hasmoved = 1
            elif cmd in [KEYUP,ord('k')]:
                ny = max (0,y-1)
                hasmoved = 1
            elif cmd in [KEYLEFT,ord('h')]:
                nx = max (0,x-1)
                hasmoved = 1
            elif cmd in [KEYRIGHT,ord('l')]:
                nx = min(x+1,LV_W-1)
                hasmoved = 1
            if hasmoved:
                if isnonsolid(lvl[nx][ny]):
                    floodfill(nx,ny)

                                
                for e in entities: #hit entities hit enemy
                    if( (e[0]==nx) and (e[1]==ny)):

                        if e[2] == "Gnome" and e[4].status != GN_DONE:
                            if (len(inventory)<MAXINV) and  (randint(0,2) + (not attributes[ATTR_STRONG_HANDS]))<1:
                                mess("You catch a Gnome")
                                inventory.append([0,0,OBJ_GNOME,e[5]])
                                entities.remove(e)
                                return True 
                            else:
                                mess("The Gnome slips from your hands.")
                                return True

                        elif ( e[3] == "Succubus")  and curss[CURS_LOVE] > 0:
                            mess("You are unable to hit the Succubus")
                            return False


                        else:
                            tpow = atk
                            for k in equip:
                                if k[0][2] == OBJ_SWORD:
                                    tpow = (atk * 3)//2
                            for k in equip:
                                if k[0][2] == OBJ_SWORD_GOLDEN:
                                    tpow = (atk * 5)//2
                            hite(e,tpow)
                            return True


                if lvl[nx][ny] == 3: #open doors
                    lvl[nx][ny] = 0
                    mess("You open the door.")
                    floodfill(nx,ny,-1,True)
                    return True
                if lvl[nx][ny] == 4: #exit
                    crawlin = False
                    mess("You descend the stairs...")
                    return True

                if lvl[nx][ny] == 7: #vending machine

                    exitgiftshop=True
                    while exitgiftshop:
                        stdscr.clear()
                        ppp = 1
                        for l in vendingback:
                            stdscr.addstr(ppp,1,l,color_pair(0))
                            ppp+=1 
                        stdscr.addstr(1,7,"THAKNAR's - GIFT SHOP")

                        lei = 1
                        for v in vmachset:
                            if(v[0] <= gold):
                                j = 0
                            else:
                                j = 4
    
                            s = "ERROR"
                            if v[1] == 0:
                                s = "Gold plate it!"
                            elif v[1] == 1:
                                s = object_names(v[2])
                            stdscr.addstr(lei + 3,6,str(lei) + ") "+ (goodstring(s)) + str(v[0])+"* ", color_pair(j))
                            lei+=1
                        stdscr.addstr(11,3,vmachword[0])
                        stdscr.addstr(12,3,vmachword[1])


                        flush_main()
                        rrrr=getchar()
                        if rrrr in [KEYENTER]:
                            exitgiftshop=False
                        elif rrrr in range(ord('1'),ord('1')+len(vmachset)):
                            ind = rrrr-ord('1')
                            if vmachset[ind][1] == 0:
                                stdscr.clear()
                                stdscr.addstr(1,1,"Choose an item to gold plate")
                                getchar()
                            if vmachset[ind][1] == 1:
                                if gold >= vmachset[ind][0]:
                                    b = color_pair(5)
                                    if len(inventory)<MAXINV:
                                        gold -= vmachset[ind][0]
                                        inventory.append(vmachset[ind][2])
                                        stdscr.addstr(3,4,"+----------------------+",b)
                                        stdscr.addstr(4,4,"*    Good choice!      *",b)
                                        stdscr.addstr(5,4,"*Thanks for stopping by*",b)
                                        stdscr.addstr(6,4,"+----------------------+",b)
                                    else:
                                        stdscr.addstr(4,6,"+---------------+",b)
                                        stdscr.addstr(5,6,"|Inventory full.|",b)
                                        stdscr.addstr(6,6,"+---------------+",b)
                                    flush_main()
                                    getchar()
                    
                    return False
   

                if lvl[nx][ny] == 101: #finale
                    finale()
                    return True

                if iswalkable(nx,ny):
                    x = nx
                    y = ny
                    turn=1  
                    return True



        #d button drop item
        if cmd == ord('d') and (len(inventory)+len(equip))>0:
            stdscr.addstr(7,7,"Select the item you want to drop")
            n = 0
            lawlz = False
            while True:
                for i in range(0,len(inventory)):
                    s = object_names(inventory[i])[:INVCLIP]
                    back.addstr(7+i,LW_W+4, s,color_pair(ssheet[inventory[i][2]][1]))
                for i in range(0,len(equip)):
                    back.addstr(3+i,LW_W+4, object_names(equip[i][0])[:INVCLIP])

                if n < len(equip):
                    back.addstr(3+n,LW_W+4, object_names(equip[n][0])[:INVCLIP], color_pair(9))
                else:
                    s = object_names(inventory[n-len(equip)])[:INVCLIP]
                    back.addstr(7+n-len(equip),LW_W+4, s,color_pair(9))
                blitback()
                blitlvl()
                flush_main()
                s = getchar()

                if s == KEYDOWN:
                    n = (n+1)%(len(inventory)+len(equip))
                elif s == KEYUP:
                    n = (n-1)%(len(inventory)+len(equip))
                elif s == KEYENTER:
                    lawlz = True
                    turn = True
                    break
                else:
                    turn = False
                    break

            it = n
            if lawlz:
                    
                if it>=len(equip):
                    pos = it - len(equip)
                    #special droppings
                    if inventory[pos][2] == OBJ_GNOME:
                        mess("You let "+inventory[pos][3].name+" go")
                        gibby = [x,y]+bosses["Gnome"] + [gnomeBrain(),inventory[pos][3]]
                        gibby[4].status = GN_FULL
                        entities.append(gibby)
                        del inventory[pos]
                    else: #ordinary droppings (special effects)
                        sbobs=False
                        if inventory[pos][2] == OBJ_STONE:
                            for e in objects:
                                if (e[2] == OBJ_PLANT) and (e[4] == 1 ) and (e[0]==x) and (e[1]==y):
                                    sbobs = True
                        mess("You drop the "+object_names(inventory[pos]))
                        if lvl[x][y] == 8:
                            mess("...it is consumed by the lava")
                        else:
                            objects.append([x,y]+inventory[pos][2:])

                        del inventory[pos]

                        if sbobs:
                            mess("The stone breaks the Stramonium")
                            mess("Out comes a litte seed...")
                            objects.append([x,y,OBJ_STRAMONIUM_SEED])
                else: 
                    pos = it
                    mess("You drop the "+object_names(equip[pos][0]))
                    if lvl[x][y] == 8:
                        mess("...it is consumed by the lava")
                    else:
                        objects.append([x,y]+equip[pos][0][2:])
                        del equip[pos]
            return turn
    
        
        #a button pick up objects
        if cmd == ord('a'):
            found=[]
            oc = objects
            MAXAX = 10
            ccc = 0
            for i in range(0,len(oc)):
                o = oc[i]
                if ((o[0] == x) and (o[1] == y)):
                    found.append(i)
                    ccc+=1
                if ccc >= MAXAX:
                    break

            if len(found)==0:
                o = -1
                mess("There is nothing here.")

            elif len(found)==1:
                o = oc[found[0]]
            else:
                z = 0
                while True:
                    h = 5
                    for j in range(0,len(found)):
                        f = found[j]
                        if j == z:
                            c = color_pair(1)
                        else:
                            c = color_pair(0)
                        stdscr.addstr(h,5,object_names(oc[f]),c)
                        h+=1
                    flush_main()
                    fff = getchar()
                    if fff == KEYUP:
                        z = (z-1)%len(found)
                    elif fff == KEYDOWN:
                        z = (z+1)%len(found)
                    elif fff == KEYENTER:
                        break
                    else:
                        return False
                o = oc[found[z]]
            

            if o != -1:
                    if o[2] == OBJ_PUKE:
                        mess("Someone else is going to clean that.")
                        return False
                    elif o[2] == OBJ_CHESTMONSTER:
                        mess("The object explodes in a swarm of enemies",4)
                        w = randint(3,8)
                        koth = []
                        cnt = 0
                        for p in range(0,w):
                            px = x
                            py = y
                            while (not isfreepos(px,py)) and cnt < 500 and (not [px,py] in koth):
                                cnt +=1
                                px += randint(-1,1)
                                py += randint(-1,1)
                                px = max(0, min(px,LV_W-1))
                                py = max(0, min(py,LV_H-1))
                            koth.append([px,py])

                        for j in koth:
                            entities.append(j+list(mobs[randint(stage//3,stage//2)]))
                        objects.remove(o)
                        return True
                    elif o[2] == OBJ_PLANT:
                        if additem(o):
                            mess("You pick up a "+object_names(o))
                            if o[3] == 1:
                                gloves=0
                                for k in equip:
                                    if k[0][2]==OBJ_GLOVES:
                                        gloves=1
                                if gloves == 0:
                                    hitp(10,True)
                                    mess("You got stung by the herb. -10 HP",4)
                            objects.remove(o)
                            return True
                        else:
                            mess("Your inventory is full",3)
                            return False
                    else:
                        if additem(o):
                            mess("You pick up a "+object_names(o))
                            objects.remove(o)
                            return True
                        else:
                            mess("Your inventory is full",3)
                            return False
        
        #cast spell
        if cmd == ord('c'):
            if mana > 0:
                wand = 0
                for k in equip:
                    if k[0][2]==OBJ_WAND:
                        wand = 1
    
                ccc = [color_pair(n) for n in [6,9,11,1]]
                cck = [color_pair(n) for n in [8,4,3,0]]
                l = 0
                c = 0
                doit = False
                
                #patch = [ [j,i, mypad.inch(j,i) ] for i in range(max(0,x-10),min(LV_W,x+10)) for j in range(max(0,y-10),min(LV_H,y+10))]
                while not doit:
                   # for gag in patch:
                   #     addchsafe(gag[0],gag[1],gag[2],color_pair(0))
                    draw()
                    if l!=3:
                        
                        rw = spellrange(spellbook[l][c][1])
                        if rw > -1: 
                            y0 = max(0,y-rw)
                            y1 = min(LV_H-1,y+rw)
                            x0 = max(0,x-rw)
                            x1 = min(LV_W-1,x+rw)

                            jobs = [ [j,i] for j in [y0,y,y1] for i in [x0,x,x1] ]
                            for jib in jobs:
                                if jib != [y,x]:
                                    addchsafe(jib[0],jib[1],'*',cck[l])

                    blitlvl()                        

                    for p in range(0,10):
                        stdscr.addstr(2+p,LW_W+4,' '*13,0)
                    t = 0
                    for i in range(0,4):
                        if l==i:
                            stdscr.addstr(2,LW_W+4+t,classnames[i].ljust(10),ccc[i])
                            if l!=3:
                            
                                for i in range(0,min(spellsprog[l],len(spellbook[l]))):
                                    if c == i:
                                        sbcol = color_pair(13)
                                    else:
                                        sbcol = cck[l]
                                    stdscr.addstr(3+i,LW_W+4+t,(str(spellbook[l][i][0])+" "+spellbook[l][i][2]).ljust(10),sbcol)
                            t+=10
                        else:
                            stdscr.addch(2,LW_W+4+t,'*',ccc[i]) 
                            t+=1
                    
                    flush_main()
                    lek=getchar()
                    if lek == KEYRIGHT:
                        l = (l+1)%4
                        c = 0
                    if lek == KEYLEFT:
                        l = (l-1)%4
                        c = 0                   
                    if lek == KEYUP and l!=3:
                        c = (c-1)%min(spellsprog[l],len(spellbook[l]))
                    if lek == KEYDOWN and l!=3:
                        c = (c+1)%min(spellsprog[l],len(spellbook[l]))

                    if lek == KEYENTER:
                        doit = True

                if (l != 3) and (spellsprog[l]>0):
                    if mana >= spellbook[l][c][0]:
                        spellcast(spellbook[l][c][1])
                        mana -= spellbook[l][c][0]
                        return True
                    else:
                        mess("You don't have the mana for that.",3)
                        return False

                else:
                    return False
                        
            else:
                mess("You don't have any mana to perform magic with",3)
                return False
    
        # use object (0-9)
        lawlz = False
#       if cmd  in range(ord('0'),ord('9')+1):
#           lawlz = True    
#           touse = cmd-ord('0')
        if cmd == ord('u') and len(inventory)>0:
            n = 0
            while True:
                for i in range(0,len(inventory)):
                    s = object_names(inventory[i])[:INVCLIP]
                    back.addstr(7+i,LW_W+4, s,color_pair(ssheet[inventory[i][2]][1]))
                s = object_names(inventory[n])[:INVCLIP]
                back.addstr(7+n,LW_W+4, s,color_pair(6))
            
                blitback()
                blitlvl()
                flush_main()
                s = getchar()

                if s == KEYDOWN:
                    n = (n+1)%len(inventory)
                elif s == KEYUP:
                    n = (n-1)%len(inventory)
                elif s == KEYENTER:
                    lawlz = True
                    touse = n
                    break
                else:
                    return False
                    break
    
        if lawlz:
            turn = True
            if touse in range(0,len(inventory)):
                idd = inventory[touse][2]
                if idd == OBJ_LETTER:
                    data = [
",---------------------------------------------.",
"(G|                                           |"] + [
"  |                                           |"]*20 + [
"  | .-------------------------------------------.",
"  l  )                                          )",
"   '=-------------------------------------------'"]

                    data2 = [
    "Dear {0},".format(name),
    "   It has been noted you are a valuable  ",
    "warrior. We thought it would be extremely",
    "nice if you descended through the dark   ",
    "rooms of the deep dungeon of {0}".format(dungeonname),
    "where the dark mage Oskar, escaped from  ",
    "the Royal Prisons, is hiding, and murder ",
    "him. The reward will be conspicuous.     ",
    "",
    "                        His Majesty      "
                    ]

                    yyy=2
                    for l in data:
                        stdscr.addstr(yyy,2,l)
                        yyy+=1
                    yyy=4
                    for l in data2:
                        stdscr.addstr(yyy,6,l)
                        yyy+=2  
                    flush_main()
                    getchar()
                elif idd == OBJ_PAPER:
                    data = clues[inventory[touse][3]]                   
                    yyy=2
                    for l in data:
                        stdscr.addstr(yyy,2,l)
                        yyy+=1
       
                    flush_main() 
                    getchar()
                    
                elif idd == OBJ_BREAD:
                    mess("You eat the bread. +25 HP",2)
                    hp = min(mxhp,hp+25)
                    del inventory[touse]
                elif idd == OBJ_GOULASH:
                    mess("You eat the goulash. +50 HP",2)
                    hp = min(mxhp,hp+50)
                    del inventory[touse]
                elif idd == OBJ_PASTA:
                    mess("You eat the pasta. +100 HP",2)
                    hp = min(mxhp,hp+100)
                    del inventory[touse]
                elif idd == OBJ_CARCASS:
                    if randint(0,1)==0:
                        s=inventory[touse][3]*2 + randint(0,2)
                        mess("You eat the carcass (+"+str(s)+" HP)",2)
                        hp = min(mxhp,hp+s)
                    else:
                        mess("The meat makes you horribly sick",3)
                        curss[CURS_POISON] += 60 + randint(0,30)
                    del inventory[touse]
                elif idd == OBJ_FAIRY_LIVER:
                    b = randint(40,80)
                    mess("You eat the liver. +"+str(b)+" MANA")
                    mana = min(mana+b,MAXMANA)
                    del inventory[touse]
                elif idd == OBJ_GNOME:
                    l = inventory[touse][3].loot 
                    if l == -1:
                        mess("The gnome is not carrying anything")
                    elif l[2] == OBJ_GOLD:
                        mess("You get back your money")
                        gold += l[3]
                    else:
                        mess("You shake the gnome and your "+object_names(l) +" comes out.")
                        objects.append([x,y] + l[2:])

                    inventory[touse][3].loot = -1

                elif idd == OBJ_PLANT:
                    species = inventory[touse][4]
                    adj = inventory[touse][3]
                    bonus = 1
                    if adj == 5:
                        bonus = 4
                    elif adj == 4:
                        bonus = 2
                    elif adj == 1:
                        mess("You get stung by the herb (-10 HP)")
                        hitp(10,True)
                    elif adj == 2:
                        mess("This plant is sacred to the gods. +2 MANA")
                        mana=min(mana+2,MAXMANA)
                    elif adj == 3:
                        if curss[CURS_ICE] > 0:
                            mess("The plant unfreezes you")
                        curss[CURS_ICE] = 0
                    
                    if(species == 0):
                        hp = min(mxhp,hp+40*bonus)
                        mess("The herb makes you healthier. (+"+str(40*bonus)+" HP)")
                    elif species == 1:
                        hitp(30*bonus,True)
                        curss[CURS_POISON] = 100*bonus
                        mess("You eat the herb and feel very, very ill...",4)
                    elif species == 2:
                        mana=min(mana+2*bonus,MAXMANA)
                        mess("You eat the Sage. (MANA +"+str(2*bonus)+")")
                    elif species == 3:
                        if randint(0,4)<3:
                            atk+=bonus
                            mess("The herb makes you stronger. (ATK +"+str(bonus)+")")
                        else:
                            mess("You eat the herb, but nothing happens.")
                    elif species == 4:
                        if randint(0,2)==0:
                            dfn+=bonus
                            mess("You feel more resistant. (DEF +"+str(bonus)+")")
                        else:
                            mess("You eat the herb, but nothing happens.")
                    else:
                        mess("You eat the herb, but nothing happens.")
                        
                    del inventory[touse]

                elif idd == OBJ_BOOK_BOTANY:
                    count = 0
                    for p in inventory:
                        if p[2] == OBJ_PLANT:
                            if p[5] == 0:
                                count += 1
                            p[5] = 1
                    mess(str(count)+" plants were identified.")
                    del inventory[touse]
                elif idd == OBJ_BOOK_TELEPORTATION:
                    spellcast(SPELL_TELEPORT)
                    del inventory[touse]
                elif idd == OBJ_BOOK_FIRE:
                    spellcast(SPELL_FIRE)
                    del inventory[touse]
                elif idd == OBJ_BOOK_THUNDER:
                                        spellcast(SPELL_THUNDER)
                                        del inventory[touse]

                elif idd == OBJ_BOOK_GEOGRAPHY:
                    exx=-1
                    exy=-1
                    for i in range(0,LV_W):
                        for j in range(0,LV_H):
                            if lvl[i][j] == 4:
                                exx=i
                                exy=j
                    if (exx>=0) and (exy>=0):
                        nonon=""
                        if (exx-x>0):
                            nonon+= str(exx-x)+"E " 
                        elif exx-x<0:
                            nonon+= str(x-exx)+"W "

                        if (exy-y>0):
                            nonon+=str(exy-y)+"S"
                        elif (exy-y<0):
                            nonon+=str(y-exy)+"N"
                        
                        mess("Exit is "+nonon+" from you.")
                    else:
                        mess("There is no exit...")
                    del inventory[touse]

                elif idd == OBJ_BOOK_TRANSMIGRATION:
                    spellcast(SPELL_TRANSMIGRATION)
                    del inventory[touse]                        



                elif idd == OBJ_HANDBOOK:
                
                    jobby=False
                    c = 0
                    while not jobby:
                        stdscr.addstr(0,2,"CHOOSE CATEGORY",color_pair(10))
                        for i in range(0,3):
                            if c == i:
                                cil = color_pair(11)
                            else:
                                cil = color_pair(0)
                            if spellsprog[i]>=len(spellbook[i]):
                                gigga = " no more spells."
                            else:
                                gigga = " " + spellbook[i][spellsprog[i]][2]
                            stdscr.addstr(3+i,3,classnames[i] + gigga,cil)
                        flush_main()
                        q = getchar()
                        if q == KEYDOWN:
                            c = (c+1)%3
                        if q == KEYUP:
                            c = (c-1)%3
                        if q == KEYENTER:
                            jobby = True
                    spellsprog[c] += 1
                    mess("You learn a new spell.")

                    del inventory[touse]
         

                elif idd in range(200,300):
                    if len(equip) < 3:
                        mess("You equip the "+object_names(inventory[touse]))
                        equip.append([inventory[touse],100])
                        del inventory[touse]
                    else:
                        mess("You can't equip any more items")

                else:
                    turn = False
                    mess("You cannot use that.")
            else:
                turn = False
                mess("That slot is empty")
            return turn

        #z button sort inventory
        if cmd == ord('z'):
            mess("You sort your inventory")
            inventory.sort(key = lambda object: object_names(object).lower() )
            return False

        #q button see history
        if cmd == ord('q'):
            p = len(messages)-24
            while True:
                stdscr.clear()
                yy = 1
                for m in messages[max(0,p) : min(len(messages),p+24) ] :
                    stdscr.addstr(yy,1,m[0],color_pair(m[1]))
                    yy+=1
                flush_main()
                qeqr = getchar()
                if qeqr in [KEYDOWN,ord('j')]:
                    p = min(len(messages)-24,p+1)
                if qeqr in [KEYUP,ord('k')]:
                    p = max(0,(p-1))
                if qeqr in [KEYLEFT,ord('h')]:
                    p = max(0,(p-10))
                if qeqr in [KEYRIGHT,ord('l')]:
                    p = min(len(messages)-24,p+10)
                if qeqr in [KEYENTER,ord('q')]:
                    break    
            return False
                
            

        #i button (stats screen) i panel
        if cmd == ord('i'):
            stdscr.clear()

            for i in range(1,50):
                stdscr.addch(2,i,".")

            
            sss = ", water will enter dungeon in "+str(abs(waterlvl-WATSTEPS)) + " turns."          
            if waterfrozen:
                sss = ", water is frozen."
            sad = ""

            if (waterlvl//WATSTEPS)>0:
                sad = " (next in "+str(WATSTEPS - waterlvl%WATSTEPS) + " turns.)"
                sss = ", water at floor "+str(waterlvl//WATSTEPS) + sad
                if waterfrozen:
                    sss = ", water is frozen."
                for i in range(1,waterlvl//WATSTEPS+1):
                    if waterfrozen:
                        stdscr.addch(2,i,"/",color_pair(15))
                    else:
                        stdscr.addch(2,i,"~",color_pair(6))


            stdscr.addstr(1,1,"Floor: "+str(stage).zfill(2) + "/50"+sss)
            if (waterlvl//WATSTEPS>=stage):  
                stdscr.addch(2,stage,"@",color_pair(6))
            else:
                stdscr.addch(2,stage,"@")

            lc = color_pair(2) #5

            stdscr.addstr(4,1," "*30,lc)
            stdscr.addstr(4,1,"EMERALDS",lc)
            for i in range(0,7):
                for j in range(0,7):
                    if gems[j*7+i]:
                        stdscr.addch(6+j,2+i,'*',color_pair(2))
                    else:
                        stdscr.addch(6+j,2+i,'.')

            stdscr.addstr(4,15,"EXP "+str(exp)+"/"+str(exprofile(rank)), color_pair(3))
            stdscr.addstr(6,14,"(          )")
            n = exp*10//exprofile(rank)  
            stdscr.addstr(6,15," "*n,color_pair(6))

            stdscr.addstr(10,15,"SPELLBOOK")
            for i in range(0,3):
                for j in range(0,len(spellbook[i])):
                    if j < min(spellsprog[i],len(spellbook[i])):
                        ccceee = color_pair(0)
                    else:
                        ccceee = color_pair(4)
                    stdscr.addstr(12+j,15 + 4*i, spellbook[i][j][2][:3].upper(),ccceee)
    
            '''stdscr.addstr(4,30, "ORIENTATION")
    
            sttx = 31
            stty = 10
            for i in range(0,5):
                for j in range(0,5):
                    if(i+j<=4):
                        c=(' ',C_WHITE)
                        if (i==0) and (j==0):
                            c=(' ',C_WHITERED)
                        if (i==4) and (j==0):
                            c=(' ',C_WHITEYELLOW)
                        if (i==0) and (j==4):
                            c=(' ',C_WHITEBLUE)
                        if (i+j == 1):
                            c=('%',C_WHITERED)
                        if (i==3):
                            c=('%',C_WHITEYELLOW)
                        if (j==3):
                            c=('%',C_WHITEBLUE)
                        if ([i,j]==orientation):
                            c = ('@',color_pair(0))'''


                            
            stdscr.addstr(4,31,"CURSES",color_pair(4))
            if sum(curss) == 0:
                stdscr.addstr(6,31,"You are fine.")
            else:
                t = 0
                for c in range(0,len(curss)):
                    if curss[c] > 0:
                        stdscr.addstr(6+t,31,curses_names[c]+" ("+str(curss[c])+")")
                        t+=1
            


            stdscr.addstr(18,1,"ATTRIBUTES")
            u = 0
            for j in range(0,len(attributes)):
                if attributes[j]:
                    stdscr.addstr(20+u,1,attribute_strings[j][0])
                    u+=1

            flush_main()
            getchar()
            return False

        #? button
        if cmd == ord('?'):
            stdscr.clear()
            for i in range(0,len(helppanel)):
                stdscr.addstr(i,0,helppanel[i])
            flush_main()
            getchar()
            return False   

        #skip turn s button
        if cmd == ord('s'):
            mess("You skip a turn.")
            return True

        #suicide
        if cmd == ord('p'):
            stdscr.addstr(7,7,"Are you sure you want to kill yourself? (Y/N)")
            flush_main()
            sure = getchar()
            if (sure in [ord('y'),ord('Y')]):
                mess("You commit suicide.")
                crawlin=False
                alive=False
            return True

        #toggle dots toggle visibility toggle fov toggle
        if cmd == ord('v'):
            visibility_dots = not visibility_dots
            return False

        #DEBUG COMMANDS 
        #next level
        #mana cheat
        if DEBUG:
            if cmd == ord('n'):
                crawlin=False
                return True
            if cmd == ord('m'):
                gold=999
                mana=999
                givexp(500)
            if cmd == ord('b'):
                for i in range(0,len(gems)):
                    gems[i] = True
            if cmd == ord(','):
                stage=34
                crawlin=False
            return False

        return turn


stdscr.clear()
flush_main()

if DEBUG:
    spellsprog = [9]*3

alive=True
stage=0
WATSTEPS=600
waterlvl=-300
#preliminary positioning (for functions)
x=-1
y=-1
clairvoying=False
visibility_dots=True
fovBrain = Map()
while alive:
    if waterfrozen:
        waterfrozen=False
        mess("The ice melts...")
    stage+=1
        
    objects = []
    entities = []

    if stage<50:
        #LEVEL GENERATION


        #try generation
        trygen = True
        trycount = 0
        reasons = []
        while trygen:
    
            mapper=dMap()
            stdscr.clear()
            stdscr.addstr(3,3,"Generating dungeon..." + (trycount>=1)*(" ("+str(trycount)+")"))
            asfd = 5
            reasons = reasons[-5:]
            for r in reasons:
                stdscr.addstr(asfd,3,r)
                asfd += 1
            flush_main()

            reasons = []

            dragonfactor = 2 * (stage**2)//(50**2)
            if DEBUG and stage==1:
                dragonfactor = 2
            
            if stage % 5 != 0:
                dtype = 0 
                lestries = 0
                while not mapper.makeMap(LV_W,LV_H,110,10+dragonfactor,dragonfactor,60):
                    lestries+=1
                lvl = [[converter[mapper.mapArr[j][i]] for i in range(0,LV_W)] for j in range(0,LV_H)]
            else:
                dtype = 1
                mapper.makeVillage(60,60)
                lvl = [[converter2[mapper.caveArr[j][i]] for i in range(0,LV_W)] for j in range(0,LV_H)]
            
            #correct naked edges
            for i in range(LV_W):
                for j in range(LV_H):
                    if lvl[i][j] == 2:
                        shit = False
                        for a in range(max(0,i-1),1+min(LV_W-1,i+1)):
                            for b in range(max(0,j-1),1+min(LV_H-1,j+1)):
                                if ispathable(lvl[a][b]):
                                    shit = True
                                    break   
                            if shit:
                                break
                        if shit:
                            if DEBUG:
                                mess("Corrected naked edge")
                            lvl[i][j] = 1

            #CHECKING

            trygen = False

            trycount += 1

            #count spaces
            spcount = 0
            for l in lvl:
                for j in l:
                    if j == 0:
                        spcount+=1
            if DEBUG:
                mess(str(spcount)+" free spaces")   

            if spcount < 700:
                trygen = True
                reasons.append("Dungeon was too small.")    
        
            #check connectedness
            con = [ [ 0 for y in range(0,LV_H)] for x in range(0,LV_W)]
            (gx,gy) = findfree()
            confloodfill(gx,gy)
            for i in range(0,LV_W):
                find = False
                for j in range(0,LV_H):
                    if lvl[i][j] == 0 and con[i][j] == 0:
                        trygen = True
                        reasons.append("Dungeon was not connected.")
                        if DEBUG:
                            mess("Dungeon unconnected")
                        find = True
                        break
                if find:
                    break

        #correct doors
        sas = [1,3,5]
        for i in range(0,LV_W):
            for j in range(0,LV_H):
                if lvl[i][j] == 3:
                    c = (lvl[i+1][j] in sas)+(lvl[i-1][j] in sas)+(lvl[i][j-1] in sas)+(lvl[i][j+1] in sas)
                    if c<2:
                        lvl[i][j] = 0
        
        #add lava
        if stage >= 35:
            if stage >= 40:
                mapper.gayLava(LV_W,LV_H,0.65,30,6)
            else:
                mapper.gayLava(LV_W,LV_H,0.95,30,6)
        
            for i in range(0,LV_W):
                for j in range(0,LV_H):
                    if lvl[i][j] == 0 and mapper.lavaArr[i][j] == 1:
                        lvl[i][j] = 8


        #add exit
        if stage < 50:
            (ex,ey) = findfree()
            lvl[ex][ey] = 4 
        else:
            mess("You enter the last dungeon...")

        #add vending machine
        if stage > 6:
            if randint(0,3)<3:
                mx=randint(0,LV_W-1)
                my=randint(0,LV_H-1)
                s=False
                security=0
                while ((lvl[mx][my]!=1) or (not s)) and security<3000:
                    security += 1
                    mx = randint(0,LV_W-1)
                    my = randint(0,LV_H-1)
                    s = False
                    s = isfreepos(mx+1,my) or isfreepos(mx-1,my) or isfreepos(mx,my-1) or isfreepos(mx,my+1)

                if security<3000:
                    lvl[mx][my] = 7

        #vending machine stats

        
        shuffle(catalogue)

        vmachset = catalogue[:randint(1,4)]

        vmachword = choice([
            ("Sacred to the old gods and th","e new!"),
            ("The Walmart of fairy-slayers!",""),
            ("Thaknar's (TM) denies all res","ponsibility for permadeath."),
            ("*Cough* sdnufer oN. *Cough*  ",""),
            ("You're the chosen one. In unr","elated news, we get rich."),
            ("100% organic dungeon supplies","made w/ genuine dwarf slaves"),
            ("blablabla some crap about qua","lity and customer service"),
            ("Oskar is not what they make h","im look like. He's worse!"),
            ("Murder Aradach! Oh wait, you ","are the other guy. Hah."),
            ("Does the King shop at Naderk?","I thought so."),
            ("A litte tip: the King is just","in LOVE with emeralds."),
            ("Spider Goddesses: worse than","Hitler. We hate those."),
            ("Who has 8 legs and is a God?","Nobody! AHAHAHAHAHAHAHA")
        ])
    
        stdscr.addstr(3,3,"Adding objects and entities...")
        flush_main()

        #add 15 gold pieces
        for c in range(0,15):
            (gx,gy) = findfree()
            objects.append([gx,gy,OBJ_GOLD])

        #add 0-2 mana drops
        for c in range(0,2):
            (gx,gy) = findfree()
            objects.append([gx,gy,OBJ_DROP])

        #add 1 emerald
        for c in range(0,1):
            (gx,gy) = findfree()
            objects.append([gx,gy,OBJ_EMERALD])
    
        #add food
        for c in range(0,randint(0,2)):
            (gx,gy) = findfree()
            objects.append([gx,gy,OBJ_BREAD])
        if stage > 5:
            for c in range(0,randint(0,1+min(1,stage//14))):
                (gx,gy) = findfree()
                objects.append([gx,gy,OBJ_GOULASH])
        if stage > 27:
            for c in range(0,randint(0,2)):
                (gx,gy) = findfree()
                objects.append([gx,gy,OBJ_PASTA])
    
        #add plants
        if stage < 25:
            totpla = 4
        else:
            totpla = 1
        for c in range(0,randint(1,totpla)):
            gx = 0
            gy = 0
            while not isfree(lvl[gx][gy]):
                gx = randint(0,LV_W-1)
                gy = randint(0,LV_H-1)
            objects.append([gx,gy]+ranplant())

        #add books
        for c in range(0,randint(0,4)):
            (gx,gy) = findfree()
            objects.append([gx,gy,randint(100,MAXBOOK)])

        #add handboooks
        if randint(0,7) == 0:
            (gx,gy) = findfree()
            objects.append([gx,gy,OBJ_HANDBOOK])

        #add armour
        for c in range(0,randint(0,3+stage//3)):
            (gx,gy) = findfree()
            objects.append([gx,gy,randint(200,MAXARMOUR)])

        for c in range(0,randint(0,stage//25)):
            (gx,gy) = findfree()
            objects.append([gx,gy,randint(250,MAXGOLDEN)])

        #add stone
        if randint(0,4)<=1:
            (gx,gy) = findfree()
            objects.append([gx,gy,OBJ_STONE])

        #add mobs
        for c in range(0,15+stage//5):
            (gx,gy) = findfree()
            i = randint(min(max(0,stage//2-4-2*(i//20)),len(mobs)-1),min(stage//2,len(mobs)-1))
            entities.append([gx,gy]+list(mobs[i]))
    
        #add bosses
        #add dragon
        for i in range(0,LV_W):
            for j in range(0,LV_H):
                if lvl[i][j] == 6:
                    entities.append([i,j]+bosses["Dragon"]+[dragonBrain()])
                    lvl[i][j] = 0
        for c in range(0,0*DEBUG*10):
            (gx,gy) = findfree()
            entities.append([gx,gy] + bosses["Dragon"] + [dragonBrain()])

        #add fairy
        if (stage > 3) and randint(0,16)==0:
            (gx,gy) = findfree()
            entities.append([gx,gy]+bosses["Fairy"])

        #add chestmonster
        for c in range(0,randint(0,2)//2 + DEBUG * 0):
            (gx,gy) = findfree()
            t = choice(list(set(ssheet) - set([OBJ_GOLD,OBJ_PUKE,OBJ_EMERALD,OBJ_DROP,OBJ_CARCASS,OBJ_PLANT,OBJ_CHESTMONSTER,OBJ_GNOME])))  
            objects.append([gx,gy,OBJ_CHESTMONSTER,0,t])

        #add succubus
        if (stage in range(18,21)):
            (gx,gy) = findfree()
            entities.append([gx,gy]+bosses["Succubus"])
        
        if stage >= 43:
            for c in range(0,4):
                (gx,gy) = findfree()
                entities.append([gx,gy]+ bosses["Succubus"])
        
        #add ice trolls
        if stage in range(30,33):
            (gx,gy) = findfree()
            entities.append([gx,gy]+bosses["Ice Troll"])

        #add gnomes
        #for c in range(0,10):
        #   (gx,gy) = findfree()
        if stage > 2:
            for i in range(0,LV_W):
                for j in range(0,LV_H):
                    if lvl[i][j] == 11 and randint(0,40) == 0:
                        entities.append([i,j]+bosses["Gnome"]+[gnomeBrain(),gnomeStuff()])


        #add clues
        for c in range(0,0):
            if randint(0,16)==0:
                (gx,gy) = findfree()
                objects.append([gx,gy,OBJ_PAPER,randint(0,len(clues)-1)])

        #position player
    
        x = LV_W//2
        y = LV_H//2
        while not isfree(lvl[x][y]):
            x = randint(0,LV_W-1)
            y = randint(0,LV_H-1)


    else:
        dtype = 2
        lvl = [[2 for i in range(0,LV_W)] for j in range(0,LV_H)]
        f=open("final",'r')
        flvl = f.readlines()

        for j in range(0,len(flvl)):
            for i in range(0,len(flvl[j])):
                if flvl[j][i] == '#':
                    lvl[i][j] = 1
                if flvl[j][i] == '@':
                    lvl[i][j] = 0
                    x = i
                    y = j
                if flvl[j][i] == '=':
                    lvl[i][j] = 3
                if flvl[j][i] == '*':
                    lvl[i][j] = 10
                if flvl[j][i] == '.':
                    lvl[i][j] = 2
                if flvl[j][i] == ' ':
                    lvl[i][j] = 0
                if flvl[j][i] == 'O':
                    lvl[i][j] = 101 
                        
        f.close()



        mess("NOTE: The final level is under construction :(")
        mess("Thanks for sticking with us till now")


    camx = min(max(0,x-LW_W//2),LV_W-LW_W-1)
    camy = min(max(0,y-LW_H//2),LV_H-LW_H-2)


    fog = [[0 for j in range(0,LV_H)] for i in range(0,LV_W)]

    floodfill(x,y)
    
#   for i in range(max(0,x-8),min(LV_W,x+8)):
#       for j in range(max(0,y-8),min(LV_H,y+8)):
#           fog[i][j] = 1
    
    stdscr.clear()
    flush_main()

    crawlin=True
    while alive and crawlin:
        

        #1 PLAYER TURN
        cango=False
        while not cango:
            draw()
            cmd = getchar()
            cango = dopturn(cmd)

        #move wotah
        if not waterfrozen:
            waterlvl+=1
            if stage - waterlvl//WATSTEPS >= 3:
                waterlvl+=2
            if waterlvl==WATSTEPS*stage:
                mess("You hear water entering the dungeon...")
            if waterlvl//WATSTEPS>=stage:
                if waterlvl%15==0:
                    (xw,yw) = findfree()
                    lvl[xw][yw] = 100
                if waterlvl%10==0:
                    for i in range(0,LV_W):
                        for j in range(0,LV_H):
                            if lvl[i][j]==100:
                                for z in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:
                                    if iswalkable(z[0],z[1]):
                                        lvl[z[0]][z[1]] = 99
                    for i in range(0,LV_W):
                        for j in range(0,LV_H):
                            if lvl[i][j]==99:
                                lvl[i][j]=100
    
        #move entities
        for e in entities:
            if e[2] == 'Gnome': #gnomes (no attack)
                s = e[4].status
                if s == GN_HIDING:
                    if abs(e[0]-x)<15 and abs(e[1]-y)<15 and randint(0,3)==0 and cansee(e[0],e[1],x,y):
                        if DEBUG:
                            mess("Gnome awake")
                        e[4].status = GN_EMPTY
                if s == GN_EMPTY:
                    if abs(e[0]-x)<=1 and abs(e[1]-y)<=1:
                        if gold > 0:
                            bott = min(randint(1,3),gold)
                            gold -= bott
                            mess("A gnome strips you of your gold!",3)
                            e[5].loot = [0,0,OBJ_GOLD,bott]
                        elif len(inventory)>0:
                            ggh = randint(0,len(inventory)-1)
                            mess("A gnome strips you of your "+object_names(inventory[ggh]),3)
                            e[5].loot = inventory[ggh]
                            del inventory[ggh]
                        else:
                            mess("You have nothing to get stolen (that's sad)",3)
                        e[4].status = GN_FULL
                        
                    elif abs(e[0]-x)<19 and abs(e[1]-y)<19:
                            ex = e[0]
                            ey = e[1]
                            factx=-sgn(ex-x)
                            facty=-sgn(ey-y)
                            possible=[[ex,ey+facty],[ex+factx,ey]]
                            possiblec = possible
                            for p in possiblec:
                                if not iswalkable(p[0],p[1]):
                                    possible.remove(p)
                            if len(possible)>0:
                                (nx,ny)=choice(possible)
                            if iswalkable(nx,ny):
                                (e[0],e[1])=(nx,ny)
                
                if s == GN_FULL:
                    ex = e[0]
                    ey = e[1]
                    factx=sgn(ex-x)
                    facty=sgn(ey-y)
                    possible=[[ex,ey+facty],[ex+factx,ey]]
                    if len(possible)>0:
                        (nx,ny)=choice(possible)
                        (e[0],e[1])=(nx,ny)
                        if not isnonsolid(lvl[nx][ny]):
                            e[4].status = GN_DONE

                        
 
            elif e[3] == 'D': #dragon has different A.I.
                ex = e[0]
                ey = e[1]
                if e[8].status == DR_AWAKE:
                    if cansee(x,y,ex,ey): #move once
                            factx=-sgn(ex-x)
                            facty=-sgn(ey-y)
                            possible=[[ex,ey+facty],[ex+factx,ey]]
                    else:
                        possible=[[ex,ey],[ex,ey],[ex,ey-1],[ex,ey+1],[ex-1,ey],[ex+1,ey]]
                    possiblec=possible
                    for p in possiblec:
                        if not iswalkable(p[0],p[1]):
                            possible.remove(p)
                    if len(possible)>0:
                        (nx,ny)=choice(possible)
                    if iswalkable(nx,ny):
                        (e[0],e[1])=(nx,ny)

                    if abs(x-e[0]) + abs(y-e[1]) <= 1:    #attack physically
                        led=hitp(e[4])
                        if led>0:
                            mess("The Dragon hits you. (-"+str(led)+" HP)",4)
                        
                elif e[8].status == DR_ANGRY and e[8].charge == DR_IDLE:



                    if abs(x-e[0]) + abs(y-e[1]) <= 2:  #start breathing
                        if randint(0,1) == 0:
                            e[8].bx=-sgn(e[0]-x)
                            e[8].by=-sgn(e[1]-y)
                            mess("The Dragon breathes in...")
                            e[8].charge = DR_CHARGING
                            e[8].particles = -1

                        else:
                            if abs(x-e[0]) + abs(y-e[1]) <= 1:    #attack physically
                                led=hitp((e[4]*3)//2 )
                                if led>0:
                                    mess("The Dragon slashes you. (-"+str(led)+" HP)")


                    else:
                        for c in range(0,2):        #walk twice
                            ex = e[0]
                            ey = e[1]
                            if cansee(x,y,ex,ey):
                                    factx=-sgn(ex-x)
                                    facty=-sgn(ey-y)
                                    possible=[[ex,ey+facty],[ex+factx,ey]]
                            else:
                                    possible=[[ex,ey],[ex,ey],[ex,ey-1],[ex,ey+1],[ex-1,ey],[ex+1,ey]]
                            possiblec=possible
                            for p in possiblec:
                                if not iswalkable(p[0],p[1]):
                                    possible.remove(p)
                            if len(possible)>0:
                                (nx,ny)=choice(possible)
                            if iswalkable(nx,ny):
                                (e[0],e[1])=(nx,ny)

                elif e[8].status == DR_ANGRY and e[8].charge == DR_CHARGING:
                    hit = False
                    e[8].particles = 0
                    for i in range(0,6):
                        e[8].particles+=1
                        if (e[0] + i* e[8].bx == x) and (e[1] + i*e[8].by == y):
                            hit = True

                        if not isnonsolid(lvl [ e[0] + i* e[8].bx ] [e[1] + i*e[8].by ] ):
                            break

                    if hit:
                        hitp(500,True)
                        mess("The Dragon fries you (-500 HP)")
                    else:
                            mess("The Dragon blows fire.")
                    e[8].charge = DR_FIRING
                    

                elif e[8].status == DR_ANGRY and e[8].charge == DR_FIRING:
                    if randint(0,3) == 0:
                        mess("The Dragon becomes calm.")
                        e[8].status = DR_AWAKE
                        e[8].charge = DR_IDLE
                    else:
                        e[8].charge = DR_IDLE
                    e[8].particles = 0


            else: #not a dragon
                if ord(e[3]) in range(ord('a'),ord('z')+1):
                    if randint(0,25) > ord(e[3]) - ord('a'):
                        reps = 1
                    else:
                        reps = 2
                elif e[3] == 'D':
                    reps = 1
                else:
                    reps = 2


                if e[2] == "Fairy":
                    if randint(0,16)==0:
                        if (abs(x-e[0])+abs(y-e[1])) < 15:
                            mess("The Fairy disappears before your eyes")
                        (sx,sy)=findfree()
                        e[0] = sx
                        e[1] = sy


                for lol in range(0,reps):
                    ex=e[0]
                    ey=e[1]
                    if ((abs(ex-x)+abs(ey-y)) < 8) :
                        if (abs(ex-x)+abs(ey-y)) == 1:
                            led=hitp(e[4])
                            if led>0:
                                if randint(0,1) == 0:
                                    mess("The "+e[2]+" hits you. (-"+str(led)+" HP)",4)
                                else:
                                    mess("The "+e[2]+" strikes you. (-"+str(led)+" HP)",4)
                                if e[3] in freezinganimals:
                                    if randint(0,10)==0:
                                        curss[CURS_ICE] = randint(5,10)
                                        mess("The "+e[2]+" has frozen you",4)
                            else:
                                mess("The "+e[2]+" misses.")

                            if e[3] == 'S':
                                if (not gender) and curss[CURS_LOVE] == 0:
                                    mess("You get in love with the Succubus")
                                curss[CURS_LOVE] = 10

                            if (len(equip)>0) and (randint(0,30*(1+attributes[ATTR_STRONG_HANDS])) == 0):
                                q = randint(0,len(equip)-1)
                                mess("The "+e[2]+" has stripped you of your "+object_names(equip[q][0])+"!")
                                del equip[q]
                            possible=[]
                        else:
                            if cansee(x,y,ex,ey):
                                factx=-sgn(ex-x)
                                facty=-sgn(ey-y)
                                possible=[[ex,ey+facty],[ex+factx,ey]]
                            else:
                                possible=[[ex,ey-1],[ex,ey+1],[ex-1,ey],[ex+1,ey]]
                    else:
                        possible=[[ex,ey-1],[ex,ey+1],[ex-1,ey],[ex+1,ey]]
    
            #if e[2] == "Dragon":
            #   possible+=[[ex+i,ey+j] for i in (-1,1) for j in (-1,1)]
            #   possiblec=possible
            #   for p in possiblec:
            #       if ((p[0]-e[8])**2 + (p[1]-e[9])**2) > 5:
            #           possible.remove(p)
                    possiblec=possible
                    for p in possiblec:
                        if not iswalkable(p[0],p[1]):
                            possible.remove(p)
                    if len(possible)>0:
                        (nx,ny)=choice(possible)
                        if iswalkable(nx,ny):
                            (e[0],e[1])=(nx,ny)
        #mana grow
        if mana>0:
            manacount+=1
            if manacount%1000 == 0:
                mana = min(mana+ 1 + mana//50,MAXMANA)
    
        #checkobjcollision
        oc = objects
        for o in oc:
            if ((o[0] == x) and (o[1]==y)):
                if o[2] == OBJ_GOLD:
                    gold+=1
                    mess("You find a gold nugget")
                    objects.remove(o) 
                if o[2] == OBJ_DROP:
                    gain = randint(1,2)
                    if attributes[ATTR_PIOUS]:
                        gain = 2
                    mana=min(mana+gain,MAXMANA)
                    mess("You drink a mana drop (+"+str(gain)+")")
                    objects.remove(o)
                if o[2] == OBJ_EMERALD:
                    gems[stage-1] = True
                    mess("You find an emerald")
                    objects.remove(o) 

        #deal damage
        if lvl[x][y] == 8:
            scales=False
            for s in equip:
                if s[0][2] == OBJ_DRAGON_SCALES:
                    scales = True

            if not scales:
                dmg = int(max(mxhp*0.08,5))
                if attributes[ATTR_DRAGONBORN]:
                    dmg = dmg//2
                mess("You walk on lava (-"+str(dmg)+" HP)")
                hitp(dmg,True)

        #cure curses
        for i in range(0,len(curss)):
            curss[i]= max(0,curss[i]-1)

        #extend fog
        
        floodfill(x,y)
        floodfill(x+1,y)
        floodfill(x-1,y)
        floodfill(x,y-1)
        floodfill(x,y+1)
        #for i in range(max(0,x-4),min(LV_W,x+4)):
        #   for j in range(max(0,y-4),min(LV_H,y+4)):
        #       fog[i][j] = 1
        
        
        #check for death
        if(hp<=0):
            alive=False
    
    
        #camera
        camx = min(max(0,x-LW_W//2),LV_W-LW_W-1)
        camy = min(max(0,y-LW_H//2),LV_H-LW_H-2)
    
    
stdscr.clear()
flush_main()

if specialending <=1:
    if DEBUG:
        stdscr.addstr(3,5,"This game was in DEBUG MODE",color_pair(10))
    stdscr.addstr(2,15,"You are dead.")
    stdscr.addstr(5,5,"Last messages:")
    ppp=7
    for m in reversed(messages[-5:]):
        stdscr.addstr(ppp,8,m[0])
        ppp+=1

    stdscr.addstr(13,5,"You made it to floor "+str(stage)+" with "+str(sum(gems))+" emeralds.")

if specialending == 2:
    stdscr.addstr(7,16,"You live.")

flush_main()

c = 0
while not (c in [KEYENTER,ord(' ')]):
    c = getchar()

#END
if GRAPHIC:
    1
else:
    curses.nocbreak()
    stdscr.keypad(0)
    curses.echo()
    curses.endwin()

#print resume

if False:
    print("THIS GAME WAS IN DEBUG MODE AND A PLAYER SHEET WILL NOT BE PRODUCED.")
else:
    dname = dungeonname #choice ( [ "Ala", "Seth", "More", "Dath", "Kathra"]) + choice ( [ "go", "na" , "ka", "gu", "ni"]) + choice ( [ "r", "r", "dor"])
    print("")
    print("        _|  |_        ")
    print("       |_ >< _|       ")
    print("+-----*__|  |__*-----+")
    print("Here lies "+name+ " (ID: "+str(ID)+")")
    print("explorer of The Dungeon of "+dname+", slayer of "+str(slaindragons)+" dragons,")
    print("")
    if specialending<=0:
        print("died on floor "+str(stage) + " (may the Gods be with him)")
        print("fighting for His Majesty the King.")
    elif specialending==1:
        print("executed for treason according to the law.")
    elif specialending==2:
        print("he blessed the King with the gift of "+str(sum(gems))+" emeralds")
        print("and lived happily until old age.")
    print("")
    print(("His"*(not gender) + gender *"Her")+" belongings included:")
    for i in inventory:
        print("-"+object_names(i))
    for i in equip:
        print("-"+object_names(i[0]))
    print("")
    print("...and "+str(gold)+" gold pieces" + (specialending!=2)*(", and "+str(sum(gems))+" of the holy emeralds."))
    print("")
    print("He was a good man."*(not gender) + gender*"She was a good woman.")
    print("")
    print("+-----+ H O L E +----+")
    print("")











'''             leng=min(5+2*wand,mana)
                stdscr.addstr(7,7,"+-CAST SPELL-+")
                stdscr.addstr(8,7,"*" + (12-leng)/2*" " +leng*"_"  + (13-leng)/2*" "+"*")
                stdscr.addstr(9,7,"+------------+")
                flush_main()
                c = 0
                s = ""
                while c!= ord('\n') and len(s)<leng:
                    c=getchar()
                    if c>250:
                        c=0
                    if chr(c) in ['q','w','e','r']:
                        s+=chr(c)
                        stdscr.addstr(8,8+ (12-leng)/2,s)
                        flush_main()

                mana= max(0,mana - len(s))
                mess("You cast the spell '"+s+"' (-"+str(len(s))+" MANA)")
                found=False
                if s.find("eqqr") != -1:
                    found = True
                    spellcast(SPELL_FIRE)
                if s.find("ewq") != -1:
                    found = True
                    spellcast(SPELL_TELEPORT)
                if (s.find("wwq") != -1)  or (s.find("qqq") != -1) or (s.find("eqe") != -1) or (s.find("rrw") != -1):
                    found = True
                    spellcast(SPELL_SUICIDE)
                if s.find("ww") != -1:
                    found = True
                    spellcast(SPELL_HEAL)
                if s.find("qeeeq") != -1:
                    found = True
                    spellcast(SPELL_GOLDEN)
                if s.find("qeqr") != -1:
                    found = True
                    spellcast(SPELL_WATCH)
                if s.find("qrw") != -1:
                    found = True
                    spellcast(SPELL_SHOCKWAVE)
                if s.find("rwe") != -1:
                                        found = True
                                        spellcast(SPELL_THUNDER)
                if s.find("req") != -1:
                    found = True
                    spellcast(SPELL_TRANSMIGRATION)
                if s.find("rqrrewr") != -1:
                    found = True
                    spellcast(SPELL_WINTER)
    
                
                if not found:
                    mess("...however, it has no effect.")'''

