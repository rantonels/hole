#!/usr/bin/env python
#coding: utf8

import sys
import __builtin__

#load and parse configuration
options = {}
try:
    configfile = open('options.cfg')
    optl = configfile.readlines()

    for l in optl:
        line = l[:-1].strip()
        if '#' in line:
            line, comment = line.split('#', 1)

        if line == "":
            1

        elif ':' in line:
            tkey, tvalue = line.split(':',1)
            options[tkey.strip()] = tvalue.strip()
        else:
            print("Error in parsing options.txt. Offending line:")
            print(l)
            print("Please ensure that lines are in the format Key:Value")
            exit()

except IOError:
    print("options.txt not found, going on...")

    

sys.setrecursionlimit(60*60)

DEBUG = False
MODE = -1
if "mode" in options:
    MODE = int(options["mode"])
if "debug" in options:
    DEBUG = int(options["debug"])

if len(sys.argv)>1:
    for a in sys.argv[1:]:
        if a == "-d":
            DEBUG = True
        elif a == "--ascii":
            MODE = 0
        elif a == "--unicode":
            MODE = 1
        elif a == "--standalone":
            MODE = 2
        else:
            print("Unrecognized option: "+a)
            exit()
        

def sgn(x):
    if x == 0:
        return 0
    if x > 0:
        return 1
    else:
        return -1
def reverse(lis):
    return lis[::-1]
def goodstring(st):
    if len(st)>16:
        return st[:14]+".."
    else:
        return st.ljust(16)




def get_line(x1, y1, x2, y2):
    #from http://roguebasin.roguelikedevelopment.org/index.php?title=Bresenham%27s_Line_Algorithm
    points = []
    issteep = abs(y2-y1) > abs(x2-x1)
    if issteep:
        x1, y1 = y1, x1
        x2, y2 = y2, x2
    rev = False
    if x1 > x2:
        x1, x2 = x2, x1
        y1, y2 = y2, y1
        rev = True
    deltax = x2 - x1
    deltay = abs(y2-y1)
    error = int(deltax // 2)
    y = y1
    ystep = None
    if y1 < y2:
        ystep = 1
    else:
        ystep = -1
    for x in range(x1, x2 + 1):
        if issteep:
            points.append((y, x))
        else:
            points.append((x, y))
        error -= deltay
        if error < 0:
            y += ystep
            error += deltax
    # Reverse the list if the coordinates were reversed
    if rev:
        points.reverse()
    return points

(WINX, WINY) = (72,35)

from random import randint

try:
    from src.dMap import *
except ImportError:
    print("could not find the crucial file dMap.py. Are you running from *inside* the hole directory?")
    exit()

try:
    import src.astar as astar
except ImportError:
    print("could not find the crucial file astar.py. Are you running from *inside* the hole directory?")
    exit()

try:
    import src.simplexnoise as simplex
except ImportError:
    print("could not find crucial file simplexnoise.py. Are you running from *inside* the hole directory?")
    exit()


try:
    import curses
    havecurses = True
except ImportError:
    print("curses library not found. Starting in standalone mode...")
    havecurses = False


if havecurses:
    stdscr = curses.initscr()
    curses.start_color()
    curses.use_default_colors()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(1)
    curses.curs_set(0)

    (WY,WX) = stdscr.getmaxyx()

    if MODE < 2:
      while WX<WINX or WY<WINY:
        (WY,WX) = stdscr.getmaxyx()

        stdscr.addstr(0,0,"SCREEN SIZE INSUFFICIENT. PLEASE RESIZE.")
        stdscr.refresh()
else:
    MODE = 2

if MODE == -1:
    stdscr.clear()
    MODE = 0
    while True:
        for i in range(0,3):
            stdscr.addstr(1+i,1,">"*(i==MODE) + ["ASCII","UNICODE","STANDALONE/GRAPHICAL"][i] + "   ")
    
        stdscr.addstr(5 ,1,"Unicode and Graphical mode are experimental.  ")
        stdscr.addstr(6 ,1,"Unicode mode extends the available characters,")
        stdscr.addstr(7 ,1,"for an interesting experience. Graphical opens")
        stdscr.addstr(8 ,1,"a standalone window. Unicode needs Python 3.3;")
        stdscr.addstr(9 ,1,"Graphical needs the pygame module.            ")
        stdscr.addstr(10 ,1,"       ")

        stdscr.addstr(12,1,"P.S.: you can avoid this prompt by appending ")
        stdscr.addstr(13,1,"the --ascii, --unicode or --standalone options")
        stdscr.addstr(14,1,"or editing options.cfg")
        stdscr.refresh()
        s=stdscr.getch()
        if s == curses.KEY_UP:
            MODE = (MODE - 1)%3
        if s == curses.KEY_DOWN:
            MODE = (MODE + 1)%3
        if s == ord('\n'):
            break

if MODE == 1:
    UNICODE = 1
else:
    UNICODE = 0

if MODE == 2:
    GRAPHIC = 1
else:
    GRAPHIC = 0

if UNICODE:
    import locale
    locale.setlocale(locale.LC_ALL,"")

#starting graphics.py (pygame) for graphic mode
if GRAPHIC:
    if havecurses:
        curses.nocbreak()
        stdscr.keypad(0)
        curses.echo()
        curses.endwin()

    try:
        import graphics
    except ImportError:
        print("Unable to import graphics.py. Are you running from the hole directory?")
        exit()
    term = graphics.Terminal(WINX,WINY,"fonts/Pastiche_16x16.png")

    stdscr = term.stdscr

graphcolors = [(0,1)]*20

if GRAPHIC:
    KEYUP = graphics.KUP
    KEYDOWN = graphics.KDOWN
    KEYLEFT = graphics.KLEFT
    KEYRIGHT = graphics.KRIGHT
    KEYENTER = graphics.KENTER
else:
    KEYUP = curses.KEY_UP
    KEYDOWN = curses.KEY_DOWN
    KEYLEFT = curses.KEY_LEFT
    KEYRIGHT = curses.KEY_RIGHT
    KEYENTER = ord('\n')

 
'''
def stdscr.addch(y,x,char,col=0):
    if GRAPHIC:
        libtcod.console_put_char(0,x,y,char, libtcod.BKGND_SET)
        
    else:
        stdscr.addch(y,x,char,col)

def stdscr.addstr(y,x,string,col=0):
    if GRAPHIC:
#        libtcod.console_set_default_foreground(0, graphcolors[col][0])
#        libtcod.console_set_default_background(0, graphcolors[col][1])
        libtcod.console_print(0,x,y, string)
    else:
        stdscr.addstr(y,x,string,col)



def flush_main():
    if GRAPHIC:
        libtcod.console_flush()
    else:
        stdscr.refresh()'''

def getchar():
    if GRAPHIC:
        return term.getch()
    else:
        return stdscr.getch()

def flush_main():
    if GRAPHIC:
        term.refresh()
    else:
        stdscr.refresh()

def blitlvl():
    global camx,camy,mypad,term
    if GRAPHIC:
        term.blit(mypad,camy,camx,1,1,LW_H+1,LW_W+1)
    else:
        mypad.noutrefresh(camy,camx,1,1,LW_H+1,LW_W+1)

def blitback():
    global back
    if GRAPHIC:
        term.blit(back,0,0,0,0,WINY,WINX)
    else:
        back.noutrefresh()

BXCHARS =   ['+','+','+','+','|','-','+','+','+','+']
if UNICODE:
    BXCHARS = [curses.ACS_ULCORNER,curses.ACS_URCORNER,curses.ACS_LLCORNER,curses.ACS_LRCORNER,curses.ACS_VLINE,curses.ACS_HLINE,curses.ACS_TTEE,curses.ACS_BTEE,curses.ACS_RTEE,curses.ACS_LTEE]

'''
╔═╦═╗╓─╥─╖╒═╤═╕┌─┬─┐
║ ║ ║║ ║ ║│ │ ││ │ │
╠═╬═╣╟─╫─╢╞═╪═╡├─┼─┤
║ ║ ║║ ║ ║│ │ ││ │ │
╚═╩═╝╙─╨─╜╘═╧═╛└─┴─┘
'''

WALLS = [
    ( '#',1),(u'═',1),(u'║',1),(u'╚',1),
    (u'═',1),(u'═',1),(u'╝',1),(u'╩',1),
    (u'║',1),(u'╔',1),(u'║',1),(u'╠',1),
    (u'╗',1),(u'╦',1),(u'╣',1),(u'╬',1) ]

BLACK = 0
RED = 1
GREEN = 2
YELLOW = 3
BLUE = 4
MAGENTA = 5
CYAN = 6
WHITE = 7


#DATA
dtypenames = ["Dungeon","Gnome Village","The End"]

classnames = [ "MIND", "BODY", "LIGHT" , "ABORT"]

DCLUT = [
# u d l r
[ 1,1,0,0],
[ 0,0,1,1]
]

NLUT = [
(1,0),
(0,1),
(-1,0),
(0,-1)
]


ITINFOBACK = '''
+----------------+-----------------------+
|                |                       |
|                |                       |
|                |                       |
|                |                       |
|                |                       |
|                | --------------------- |
|     \  /       |                       |
|      \/        | #                     |
|      /\        |                       |
|     /  \       | #                     |
|                |                       |
|                | #                     |
|                |                       |
|                | #                     |
|                |                       |
|                |-----------------------+
+----------------+                        '''[1:].split('\n')



tfile = open('sprites/title','r')
title = tfile.readlines()
tfile.close()

vfile = open('sprites/vending','r')
vendingback = vfile.readlines()
vfile.close()

cfile = open('sprites/credits','r')
creditsdata = cfile.readlines()
credits = creditsdata[:24]
creditsred = creditsdata[24:49]
creditsyellow = creditsdata[49:75]
cfile.close()

def color_pair_num(n):
    global GRAPHIC
    if GRAPHIC:
        return n
    else:
        return curses.color_pair(n)

def color_pair_fb(f,b):
    global GRAPHIC
    if GRAPHIC:
        return 0
    else:
        return curses.color_pair(STPAIR + 8*b + f)

def color_pair(cc):
    if isinstance(cc,tuple):
        return color_pair_fb(cc[0],cc[1])
    else:
        return color_pair_num(cc)

def addstrtrans(screen,y,x,string,col = color_pair(0)):
    for i in range(0,len(string)):
        if string[i] != ' ':
            screen.addch(y,x+i,string[i],col)

def isfree(num):
    return (num in [0])
def isnonsolid(num):
    return (num in [0,8])

def hall_color(color):
    global curss
    if curss[CURS_HALLUCINATION] and randint(0,4)<4:
        return color_pair_fb(randint(0,7),randint(0,7))
    else:
        return color

def hall_char(char):
    global curss
    if curss[CURS_HALLUCINATION] and randint(0,4)<4:
        if GRAPHIC:
            return chr(randint(0,255))
        else:
            return chr(randint(32,126))
    else:
        return char

def hall_floor(char):
    global curss
    if curss[CURS_HALLUCINATION] and randint(0,20)==0:
        return chr(randint(32,126))
    else:
        return char

def hall_floor_color(color):
    global curss
    if curss[CURS_HALLUCINATION] and randint(0,20)==0:
        return color_pair_fb(randint(0,7),randint(0,7))
    else:
        return color
   

class Item:
    def __init__(self, oid, x=0, y=0):
        self.ID = oid
        self.x = x
        self.y = y
    def __str__(self):
        return object_names(self)
    def sprite(self):
        return ssheet[self.ID][0]
    def colour(self):
        return ssheet[self.ID][1]
    def sameas(self,other):
        return ( (self.ID == other.ID) )
    def __getitem__(self, index): #overloading to accomodate compatibility with older item system
        dic = {
            0:self.x,
            1:self.y,
            2:self.ID
        }
        if index in dic:
            return dic[index]
        else:
            raise Exception("From item "+str(self)+" was requested the nonexisting index ["+str(index)+"]")
    def coordlist(self):
        return [self.x,self.y]
    def coords(self):
        return (self.x,self.y)
    def position(self,x,y):
        self.x = x
        self.y = y


        

class Plant(Item):
    def __init__(self,species,adj=0,identified=True,x=0,y=0):
        Item.__init__(self,OBJ_PLANT,x,y)
        self.species = species
        self.adjective = adj
        self.identified = identified
    def sameas(self,other):
        return Item.sameas(self,other) and (self.species == other.species) and (self.adjective == other.adjective)

class Carcass(Item):
    def __init__(self,wasanimal,x=0,y=0):
        Item.__init__(self,OBJ_CARCASS,x,y)
        self.original = wasanimal
    def sprite(self):
        return chr(self.original + ord('a'))

class Chestmonster(Item):
    def __init__(self,camouflage,x=0,y=0):
        Item.__init__(self,OBJ_CHESTMONSTER,x,y)
        if camouflage == OBJ_PLANT:
            self.camouflage = ranplant()
        else:
            self.camouflage = Item(camouflage)
        self.identified = False
    def sprite(self):
        if self.identified:
            return Item.sprite(self)
        else:
            return self.camouflage.sprite()
    def colour(self):
        if self.identified:
            return Item.colour(self)
        else:
            return self.camouflage.colour()

class GnomeItem(Item):
    def __init__(self,gnome,x=0,y=0):
        Item.__init__(self,OBJ_GNOME,x,y)
        self.gnome = gnome
        

class Clue(Item):
    def __init__(self,data,x=0,y=0):
        Item.__init__(self,OBJ_PAPER,x,y)
        self.data = data

class Loot(Item):
    def __init__(self,amount):
        Item.__init__(self,OBJ_GOLD)
        self.amount = amount


#OBJECT STRUCTURE:
# [0] x / null in inv
# [1] y / null in inv
# [2] id
# [3] adj
# [4] plant type
# [5] clear

MAXMANA = 300
MAXINV = 19
INVCLIP = 20

OBJ_GOLD  = 0
OBJ_PLANT = 1
OBJ_BREAD = 2
OBJ_DROP = 3
OBJ_EMERALD = 4
OBJ_GOULASH = 5
OBJ_FAIRY_LIVER = 6
OBJ_PASTA = 7
OBJ_CHESTMONSTER = 8
OBJ_STONE = 9
OBJ_STRAMONIUM_SEED = 10
OBJ_HANDBOOK = 11
OBJ_CARCASS = 12
OBJ_PUKE = 13
OBJ_GNOME = 14
OBJ_SULFUR = 15

OBJ_BOOK_BOTANY = 100
OBJ_BOOK_TELEPORTATION = 101
OBJ_BOOK_FIRE = 102
OBJ_BOOK_THUNDER = 103
OBJ_BOOK_GEOGRAPHY = 104
OBJ_BOOK_TRANSMIGRATION = 105
OBJ_BOOK_CLAIRVOYANCE = 106
OBJ_BOOK_WINTER = 107
MAXBOOK = 107

OBJ_SWORD = 200
OBJ_GLOVES = 201
OBJ_SHIELD = 202
OBJ_WAND = 203
MAXARMOUR = 203

OBJ_DRAGON_SCALES = 225

OBJ_SWORD_GOLDEN = 250
OBJ_SHIELD_GOLDEN = 251
MAXGOLDEN = 251

OBJ_LETTER = 900
OBJ_PAPER = 901

guidetopic = {
0:"Gold can be used to buy items in Gift Shops.",
1:"ERROR",
2:"Restores 25 HP",
3:"Gives 1 Mana point"
}

def object_names(obj):
    num = obj.ID
    out="ERROR"
    matr= {
    0:"Gold Nugget",
    1:"Plant_DEBUG",
    2:"Bread",
    3:"Mana Drop",
    4:"Emerald",
    5:"Goulash",
    6:"Fairy Liver",
    7:"Pasta",
    8:"False Item",
    9:"Stone",
    10:"Stramonium Seed",
    11:"Magic Handbook",
    12:"Carcass_DEBUG",
    13:"Puke",
    14:"Gnome",
    15:"Sulfur Chunk",
    
    100:"Book of Botany",
    101:"Book of Teleportation",
    102:"Book of Fire",
    103:"Book of Thunder",
    104:"Book of Geography",
    105:"Book of Transmigration",
    106:"Book of Clairvoyance",
    107:"Book of Winter",

    200:"Sword",
    201:"Gloves",
    202:"Shield",
    203:"Magic Wand",

    225:"Dragon Scales",

    250:"Golden Sword"+DEBUG*"0123456789",
    251:"Golden Shield",

    900:"Letter",
    901:"Piece of Paper"
    }
    if num in matr:
        out=matr[num]
    if num == 1:
        if isinstance(obj,Plant) and obj.identified == 1:
            if obj.adjective == 0:
                out = plants[obj.species]
            else:
                out = plant_adjectives[obj.adjective][1] + " " + plants[obj.species]
        else:
            out = "Herb"
    if num == OBJ_CARCASS:
        out = mobsalphabet[obj.original] + " Carcass" 

    if num == OBJ_CHESTMONSTER and not obj.identified:
        out = object_names(obj.camouflage)
    
    if num == OBJ_GNOME:
        out = obj.gnome.name

    return out


plant_adjectives = {
0:(0.5,"PLAIN"),
1:(0.7,"Stinging"),
2:(0.8,"Sacred"),
3:(0.9,"Spicy"),
4:(1,"Silver"),
5:(0.95,"Golden")
}

plants = {
0:("Basil"),
1:("Stramonium"),
2:("Sage"),
3:("Nettle"),
4:("Dandelion")
}

solids = []


__builtin__.UNICODE = UNICODE
__builtin__.DEBUG   = DEBUG

mobsalphabet = {
0:"Ant",
1:"Bee",
2:"Chicken",
3:"Dog",
4:"Emu",
5:"Frog",
6:"Gerbil",
7:"Hyena",
8:"Impala",
9:"Jackal",
10:"Kangaroo",
11:"Leech",
12:"Moth",
13:"Nabarlek",
14:"Ostrich",
15:"Penguin",
16:"Quetzal",
17:"Rabbit",
18:"Squid",
19:"Tiger",
20:"Uakari",
21:"Vulture",
22:"Wolf",
23:"Xanclomys",
24:"Yak",
25:"Zebra"}

animalsymbols = [chr(ord('a')+i) for i in range(0,len(mobsalphabet))]
if UNICODE:
    animalsymbols[0] = u'¥'
    animalsymbols[1] = u'ഴ'
    animalsymbols[5] = u'ൠ'
    animalsymbols[18] = u'ᴥ'
    
#don't add gerbil!

freezinganimals =      [chr(x + ord('a')) for x in ( [8,13,15,16,18,21,23,25] + [0,1]*DEBUG) ] + ['I']
hallucinatinganimals = [chr(x + ord('a')) for x in ( [5,11,12,18,23]          + [0,1]*DEBUG) ] + ['F']

aswmap = {}

def mobpathfun(sx,sy):
    return (not isnonsolid(lvl[sx][sy]))

class Brain:
    def __init__(self,parent):
        self.p = parent
        self.initState()

    def resetIdle(self):
        self.p.resetIdle()

    def initState(self):
        pass

    def doStep(self):
        self.stateMachine()
        self.doAction()

    def stateMachine(self):
        pass

    def doAction(self):
        pass

    
    def hitMessage(self):
        pass

    def deadMessage(self):
        pass

    def stateName(self):
        return "NO STATE"


    def wander(self):
        ex = self.p.x
        ey = self.p.y
        possible=[[ex,ey],[ex,ey],[ex,ey-1],[ex,ey+1],[ex-1,ey],[ex+1,ey]]
        possiblec=possible
        for p in possiblec:
            if not iswalkable(p[0],p[1]):
                possible.remove(p)
        if len(possible)>0:
            (nx,ny)=choice(possible)
            if iswalkable(nx,ny):
                (self.p.x,self.p.y)=(nx,ny)
                self.resetIdle()

    def goto(self,x,y):

        '''ex = self.p.x
        ey = self.p.y
        factx=-sgn(ex-x)
        facty=-sgn(ey-y)
 
        possible=[[ex,ey+facty],[ex+factx,ey]]

        possiblec=possible
        for p in possiblec:
            if not iswalkable(p[0],p[1]):
                possible.remove(p)'''

        p = astar.pathfind(mobpathfun,(self.p.x,self.p.y),(x,y),aswmap)
        if p == -1:
           self.wander()
        elif len(p)>1:
           (nx,ny) = p[-2]

           if iswalkable(nx,ny):
                    (self.p.x,self.p.y)=(nx,ny)
                    self.resetIdle()

    def fleeFrom(self,x,y):
        ex = self.p.x
        ey = self.p.y
        factx=sgn(ex-x)
        facty=sgn(ey-y)
 
        possible=[[ex,ey+facty],[ex+factx,ey]]

        possiblec=possible
        for p in possiblec:
            if not iswalkable(p[0],p[1]):
                possible.remove(p)
        if len(possible)>0:
            (nx,ny)=choice(possible)
            if iswalkable(nx,ny):
                (self.p.x,self.p.y)=(nx,ny)
                self.resetIdle()

    def fleeAndDefend(self):
        global x,y
        ox = self.p.x
        oy = self.p.y
        self.fleeFrom(x,y)
        if (ox,oy) == (self.p.x,self.p.y) and abs(self.p.x-x)+abs(self.p.y-y) <= 1:
           self.attack()


    def attack(self):
        global curss, equip, attributes
        led=hitp(self.p.atk)
        e = self.p
        if led>0:
                            if randint(0,1) == 0:
                                    mess("The "+e[2]+" hits you. (-"+str(led)+" HP)",4)
                            else:
                                    mess("The "+e[2]+" strikes you. (-"+str(led)+" HP)",4)
                            if e[3] in freezinganimals:
                                    if randint(0,10)==0:
                                        curss[CURS_ICE] = randint(5,10)
                                        mess("The "+e[2]+" has frozen you",4)
                            if e[3] in hallucinatinganimals:
                                    if randint(0,10)==0:
                                        curss[CURS_HALLUCINATION] = randint(2,20)
                                        mess("You start hallucinating",4)

                            if (len(equip)>0) and (randint(0,30*(1+attributes[ATTR_STRONG_HANDS])) == 0):
                                q = randint(0,len(equip)-1)
                                mess("The "+e[2]+" has stripped you of your "+object_names(equip[q][0])+"!")
                                del equip[q]

                            if e[3] == 'S':
                                if (not gender) and curss[CURS_LOVE] == 0:
                                    mess("You get in love with the Succubus")
                                curss[CURS_LOVE] = 10

        else:
           
            mess("The "+e[2]+" misses.")

                            
                            
    def pursuePlayer(self):
        global x,y
        if abs(self.p.x - x) + abs(self.p.y - y) <= 1:
           self.attack()
        else:
           self.goto(x,y)

                               



class ZombieBrain(Brain):
    def doAction(self):
        global x,y
        if (abs(self.p.x-x)+abs(self.p.y-y)) < 16 and cansee(x,y,self.p.x,self.p.y):
           self.pursuePlayer()
        else:
           self.wander()
    def stateName(self):
        
        if (abs(self.p.x-x)+abs(self.p.y-y)) < 16 and cansee(x,y,self.p.x,self.p.y):
            return "Hunting"
        else:
            return "Wandering"

DR_SLEEPING = 0
DR_AWAKE = 1
DR_ANGRY = 2

DR_IDLE = 0
DR_CHARGING = 1
DR_FIRING = 2

class DragonBrain(Brain):
    def __init__(self,parent):
        Brain.__init__(self,parent)
        self.charge = DR_IDLE
        self.bx = 0
        self.by = 0
        self.particles = 0

    def initState(self):
        self.status = randint(0,2)//2


    def doStep(self):
          ex = self.p.x
          ey = self.p.y
          if self.status == DR_AWAKE:
              if cansee(x,y,ex,ey): #move once
                     self.pursuePlayer()
                     self.pursuePlayer()


          elif self.status == DR_ANGRY and self.charge == DR_IDLE:



              if abs(x-self.p.x) + abs(y-self.p.y) <= 2:  #start breathing
                  if randint(0,1) == 0:
                      self.bx=-sgn(self.p.x-x)
                      self.by=-sgn(self.p.y-y)
                      mess("The Dragon breathes in...")
                      self.charge = DR_CHARGING
                      self.particles = -1

                  else:
                      if abs(x-self.p.x) + abs(y-self.p.y) <= 1:    #attack physically
                            self.attack()

              else:
                  for c in range(0,2):        #walk twice
                      ex = self.p.x
                      ey = self.p.y
                      if cansee(x,y,ex,ey):
                              factx=-sgn(ex-x)
                              facty=-sgn(ey-y)
                              possible=[[ex,ey+facty],[ex+factx,ey]]
                      else:
                              possible=[[ex,ey],[ex,ey],[ex,ey-1],[ex,ey+1],[ex-1,ey],[ex+1,ey]]
                      possiblec=possible
                      for p in possiblec:
                          if not iswalkable(p[0],p[1]):
                              possible.remove(p)
                      if len(possible)>0:
                          (nx,ny)=choice(possible)
                      if iswalkable(nx,ny):
                          (self.p.x,self.p.y)=(nx,ny)

          elif self.status == DR_ANGRY and self.charge == DR_CHARGING:
              hit = False
              self.particles = 0
              for i in range(0,6):
                  self.particles+=1
                  if (self.p.x + i* self.bx == x) and (self.p.y + i*self.by == y):
                      hit = True

                  if not isnonsolid(lvl [ self.p.x + i* self.bx ] [self.p.y + i*self.by ] ):
                      break

              if hit:
                  hitp(500,True)
                  mess("The Dragon fries you (-500 HP)")
              else:
                      mess("The Dragon blows fire.")
              self.charge = DR_FIRING
              

          elif self.status == DR_ANGRY and self.charge == DR_FIRING:
              if randint(0,3) == 0:
                  mess("The Dragon becomes calm.")
                  self.status = DR_AWAKE
                  self.charge = DR_IDLE
              else:
                  self.charge = DR_IDLE
              self.particles = 0   

    def hitMessage(self):
        if self.status == DR_SLEEPING:
            self.status = DR_ANGRY
            mess("You awake and anger the Dragon.")
        if self.status == DR_AWAKE:
            self.status = DR_ANGRY
            mess("The Dragon is angered")


    def stateName(self):
        if self.status == DR_SLEEPING:
            return "Sleeping"
        elif self.status == DR_AWAKE:
            return "Hunting"
        elif self.status == DR_ANGRY:
            if self.charge == DR_IDLE:
                return "Furious"
            elif self.charge == DR_CHARGIN:
                return "About to blow fire"
            elif self.charge == DR_FIRING:
                return "Blowing fire"

FR_WANDERING = 0
FR_ATTACKING = 1
FR_FLEEING   = 2

class FairyBrain(Brain):
    def teleport(self):
        if cansee(x,y,self.p.x,self.p.y):
            mess("The Fairy disappears before your eyes")
        (sx,sy)=findfree()
        self.p.x = sx
        self.p.y = sy
        self.state = FR_WANDERING

    def initState(self):
        self.state = FR_WANDERING

    def morale(self):
        return float(self.p.hp)/self.p.maxhp - 0.5 

    def stateMachine(self):
        if self.state == FR_WANDERING:
           if cansee(x,y,self.p.x,self.p.y) and (abs(self.p.x - x) + abs(self.p.y - y) < 10):
                if self.morale() > 0 and randint(0,1)==0:
                    self.state = FR_ATTACKING
                else:
                    self.state = FR_FLEEING

        elif self.state == FR_ATTACKING:
           if self.morale() < -0.20:
                self.state = FR_FLEEING
    def doAction(self):
        if self.state == FR_WANDERING:
            if randint(0,20) == 0:
               self.teleport()
            else:
                self.wander()

        elif self.state == FR_ATTACKING:
            self.pursuePlayer()
            self.pursuePlayer()

        elif self.state == FR_FLEEING:
            if randint(0,abs(self.p.x-x)+abs(self.p.y-y)) == 0:
               self.teleport()
            self.fleeAndDefend()
            self.fleeAndDefend()
            


    def hitMessage(self):
        if randint(0,5)==0:
            self.teleport()

    def stateName(self):
        if self.state == FR_WANDERING:
           return "Wandering"
        elif self.state == FR_ATTACKING:
            return "Attacking"
        elif self.state == FR_FLEEING:
            return "Fleeing"


HS_WANDERING = 0
HS_HUNTING = 1
HS_FLEEING = 2
HS_PANIC = 3

PR_TIMID = 0
PR_PRUDENT = 1
PR_AGGRESSIVE = 2

class HunterBrainAlpha(Brain):
    def __init__(self,parent,personality=PR_AGGRESSIVE):
        Brain.__init__(self,parent)
        self.personality = personality
        self.betas = []
    def initState(self):
        self.state = HS_WANDERING

   

    def stateMachine(self):
        if self.state == HS_WANDERING:
           if (abs(self.p.x-x)+abs(self.p.y-y)<18) and cansee(x,y,self.p.x,self.p.y):
                if self.personality + randint(0,1)>1:
                    self.state = HS_HUNTING
                else:
                   if randint(0,2)==0:
                        self.state = HS_FLEEING
                   else:
                      self.state = HS_WANDERING

        elif self.state == HS_PANIC:
            if randint(0,2)==0:
               self.state = HS_WANDERING

    def doAction(self):
        if self.state == HS_WANDERING:
           self.wander()
        elif self.state == HS_HUNTING:
            self.pursuePlayer()
        elif self.state == HS_FLEEING:
            self.fleeAndDefend()
        elif self.state == HS_PANIC:
            self.wander()


    def hitMessage(self):
        if self.state in [HS_WANDERING,HS_FLEEING]:
           if self.personality > PR_TIMID or randint(0,1)==0:
              self.state = HS_HUNTING
           else:
              self.state = HS_FLEEING

    def stateName(self):
        return {
           HS_WANDERING:"Wandering",
           HS_HUNTING:"Hunting",
           HS_FLEEING:"Fleeing",
           HS_PANIC:"Panicking"
        }[self.state] + (len(self.betas)>0)*" (leader)"

    def deadMessage(self):
        for i in self.betas:
           i.kingIsDeadMessage()


class HunterBrainBeta(Brain):
    def __init__(self,parent,leader):
        Brain.__init__(self,parent)
        self.leader = leader
        leader.betas.append(self)
        self.personality = self.leader.personality

        self.state = self.leader.state

    def deadMessage(self):
        self.leader.betas.remove(self)

    def stateMachine(self):
        self.state = self.leader.state
        

    def doAction(self):
        if self.state == HS_WANDERING:
           if randint(0,2)==0:
              self.goto(self.leader.p.x,self.leader.p.y)
           else:
              self.wander()
        elif self.state == HS_HUNTING:
            self.pursuePlayer()
        elif self.state == HS_FLEEING:
            self.fleeAndDefend()

    def stateName(self):
        return {
           HS_WANDERING:"Wandering",
           HS_HUNTING:"Hunting",
           HS_FLEEING:"Fleeing",
           HS_PANIC:"Panicking"
        }[self.state] + "(following leader)"

    def hitMessage(self):
        self.leader.hitMessage()


    def kingIsDeadMessage(self):
        self.p.brain = HunterBrainAlpha(self.p,self.personality)
        self.p.brain.state = HS_PANIC
     
    
GN_HIDING = 0
GN_EMPTY = 1
GN_FULL = 2
GN_DONE = 3

class GnomeBrain(Brain):
    def __init__(self,parent):
        Brain.__init__(self,parent)
        

        self.name = self.p.name

        if randint(0,0)==1:
            self.loot = -1
        else:
            self.loot = Item(OBJ_SULFUR)

    def initState(self):
        self.state = GN_HIDING

    def doStep(self):
                global x,y,gold,inventory
                s = self.state
                e = self.p
                if s == GN_HIDING:
                    if abs(e[0]-x)<15 and abs(e[1]-y)<15 and randint(0,3)==0 and cansee(e[0],e[1],x,y):
                        if DEBUG:
                            mess("Gnome awake")
                        self.state = GN_EMPTY
                if s == GN_EMPTY:
                    if isnonsolid(lvl[e[0]][e[1]]) and abs(e[0]-x)<=1 and abs(e[1]-y)<=1:
                        if gold > 0:
                            bott = min(randint(1,3),gold)
                            gold -= bott
                            mess("A gnome strips you of your gold!",3)
                            self.loot = Loot(bott)
                        elif len(inventory)>0:
                            ggh = randint(0,len(inventory)-1)
                            mess("A gnome strips you of your "+object_names(inventory[ggh]),3)
                            self.loot = inventory[ggh]
                            del inventory[ggh]
                        else:
                            mess("You have nothing to get stolen (that's sad)",3)
                        self.state = GN_FULL
                        
                    elif abs(e[0]-x)<19 and abs(e[1]-y)<19:
                           self.goto(x,y) 
                
                if s == GN_FULL:
                    ex = e[0]
                    ey = e[1]
                    factx=sgn(ex-x)
                    facty=sgn(ey-y)
                    possible=[[ex,ey+facty],[ex+factx,ey]]
                    if len(possible)>0:
                        (nx,ny)=choice(possible)
                        (e[0],e[1])=(nx,ny)
                        if not isnonsolid(lvl[nx][ny]):
                            self.state = GN_DONE


    def stateName(self):
        return {
           GN_HIDING: "Hiding",
           GN_EMPTY: "Stealing",
           GN_FULL: "Fleeing",
           GN_DONE: "Sleeping"
        }[self.state]

    
class Creature:
    def __init__(self):
        self.idlecount = 0

    def idleStep(self):
        self.idlecount += 1

    def resetIdle(self):
        self.idlecount = 0



class Entity(Creature):
    def __init__(self,x,y,name,symbol):
        Creature.__init__(self)
        self.x = x
        self.y = y
        self.name = name
        self.sprite = symbol


    def __getitem__(self,index):
        if index == 0:
            return self.x
        elif index == 1:
            return self.y
        elif index == 2:
           return self.name
        elif index == 3:
           return self.sprite
        elif index == 4:
            return self.atk
        elif index == 5:
            return self.dfn
        elif index == 6:
            return self.hp
        elif index == 7:
            return self.expbonus
       

    def __setitem__(self,index,value):
        if index == 0:
            self.x = value
        elif index == 1:
            self.y = value
        elif index == 2:
            self.name = value
        elif index == 6:
            self.hp = value

    def getShortStr(self):
        return self.brain.stateName()

    def getLongStr(self):
        return self.name + " " + self.getShortStr()

    def visible(self):
        return True

class Gnome(Entity):
    def __init__(self,x,y):
        global gnomenames
        Entity.__init__(self,x,y,choice(gnomenames),'g')
        self.brain = GnomeBrain(self)


    def visible(self):
        global clairvoying
        e = self
        return clairvoying or isnonsolid(lvl[e[0]][e[1]])
        


class Meanie(Entity):        
    def __init__(self,x,y,name,symbol,atk,dfn,maxhp,expbonus):
        Entity.__init__(self,x,y,name,symbol)
        self.atk = atk
        self.dfn = dfn
        self.maxhp = maxhp
        self.hp = self.maxhp
        self.expbonus = expbonus

        self.freezing = (self.sprite in freezinganimals)
        self.hallucinating = (self.sprite in hallucinatinganimals)

        self.brain = ZombieBrain(self)

def getShortStr(self):
        return "%s/%s HP - "%(self.hp,self.maxhp) + Entity.getShortStr(self)


class AnimalIndexError(Exception):
    pass

class Animal(Meanie):
    def __init__(self,x,y,index,personality=0):
        if not index in range(len(mobsalphabet)):
            raise AnimalIndexError
            exit()

        i = index
        Meanie.__init__(self,x,y, mobsalphabet[i] , animalsymbols[i],  2 + max(i,-25+3*i), max(1,i-1,-24+3*i), 4+2*(i+i*i//4),  i//2+1 )
        
        self.brain = HunterBrainAlpha(self,personality)
    def getLongStr(self):
        return {
            PR_TIMID:"Timid",
            PR_PRUDENT:"Prudent",
            PR_AGGRESSIVE:"Aggressive"
        }[self.brain.personality] + " " + Meanie.getShortStr(self)
 
class MagicalCreature(Meanie):
    pass

class Dragon(MagicalCreature):
    def __init__(self,x,y):
        Meanie.__init__(self,x,y, "Dragon",'D', 150, 80, 1000,300)
        self.brain = DragonBrain(self)


class Fairy(MagicalCreature):
    def __init__(self,x,y):
        Meanie.__init__(self,x,y, "Fairy" ,  'F', 8 , 20,  300, 100)
        self.brain = FairyBrain(self)


class IceTroll(MagicalCreature):
    def __init__(self,x,y):
        Meanie.__init__(self,x,y,"Ice Troll" , 'I', 100, 60, 350, 300)
        self.brain = HunterBrainAlpha(self,PR_AGGRESSIVE)

class Succubus(MagicalCreature):
    def __init__(self,x,y):
        Meanie.__init__(self,x,y,"Succubus" , 'S', 25,10,120,5)
        self.brain = HunterBrainAlpha(self,randint(PR_PRUDENT,PR_AGGRESSIVE))



#atk            #dfn                #hp         #exp
mobs = [[mobsalphabet[i] , animalsymbols[i],  2 + max(i,-25+3*i), max(1,i-1,-24+3*i), 4+2*(i+i*i//4),  i//2+1] for i in range(0,len(mobsalphabet))]


freezinganimals =      [chr(x + ord('a')) for x in ( [8,13,15,16,18,21,23,25] + [0,1]*DEBUG) ] + ['I']
hallucinatinganimals = [chr(x + ord('a')) for x in ( [5,11,12,18,23]          + [0,1]*DEBUG) ] + ['F']

bosses = {
    "Dragon":   ["Dragon",  'D', 150, 80, 1000,300],
    "Fairy":    ["Fairy" ,  'F', 4 , 18,  70, 100],
    "Ice Troll":    ["Ice Troll",   'I', 100, 60, 350, 300],
    "Succubus" :    ["Succubus",    'S', 18, 10, 120, 5 ],
    "Gnome":    ["Gnome",   'g']
}



if UNICODE:
    bosses["Succubus"][1] = u'☿'



gnomenames = "Berenbur Minnimalkin Bimpni Minnizig Boddywinkle Murkor Bunkkor Nacklebell Cobbnab Namji Dalfoodle Namzig Duvabert Ninbert Duvakor Pilwinkle Elmadge Ranzbert Folmalkin Ranzmut Fudwick Ranznor Garder Roywinkle Glimtwiss Schepgel Hedbiddle Schepmalkin Jebkor Shamip Klemmut Turkor Klemto Wayfoodle Lindtwiss Waypest Looppen Wayrick Loopwyn Zookmadge Lumbiddle Zookmottin Lumwinkle Zooknock Mibbini Zookpen Minnibur Zookwinkle Minnijon".split(" ")


'''mobs = {
0:("Worm"   ,'w',1,0,5 ,2),
1:("Frog"   ,'f',1,1,8 ,3),
2:("Moth"   ,'m',2,0,10,3),
3:("Squid"  ,'s',2,2,11,5),
4:("Leech"  ,'l',3,2,14,7),
5:("Rabbit" ,'r',4,3,16,9),
6:("Zombie" ,'z',5,2,19,11),
7:("Tiger"  ,'t',8,4,22,13),
8:("Ghost"  ,'g',7,6,24,14)
}'''



def add_pack(index,sx,sy,minn=2,maxn=6):
    if minn>=maxn:
        n = maxn
    else:
        n = randint(minn,maxn)

    global entities
    lead = Animal(sx,sy,index,randint(1,2))
    entities.append(lead)

    for _ in range(n-1):
       fol = Animal(sx,sy,index)
       fol.brain = HunterBrainBeta(fol,lead.brain)

       entities.append(fol)

def compileWmap():
    global entities,aswmap
    aswmap = {}
    for e in entities:
       e.idleStep()
       aswmap[(e.x,e.y)] = e.idlecount


LV_W =60
LV_H =60
LW_W =45
LW_H =20

converter = {
0:0,
1:2,
2:1,
3:3,
4:3,
5:3,

55:11,

66:8,

98:6,
99:5
}

converter2 = {
0:0,
1:2,
2:12,
3:3,
4:3,
5:3,
55:11,
66:8,
98:6,
99:5
}

#TILESET and SPRITESHEET
tset = {
0: (' ',0), #walkable empty tile
1: ('#',(BLACK,WHITE)), #wall
2: (' ',0), #unexplored/outside
3: ('/',(YELLOW,BLACK)), #door
4: ('v',0), #exit
5: ('#',7), #golden wall
6: ('X',7), #golden column
7: ('$',9), #gift shop
8: ('~',12),    #lava
9: ('*',2), #emerald walkway
10: ('.',0),    #emerald walkway (not activated)
11: ('$',1),    #dirt
12: ('%',5),    #wood
13: ('~',(CYAN),(BLACK)),   #shallow water

100: ('~',6),   #water
101: ('@',10)   #Oskar
}

luminescent = [8]

if UNICODE:
    tset[100] = (u'♒',6)

xaminetiles = {
    1: "It's a sturdy stone wall.",
    2: "Uhmm... you shouldn't be able to see this...",
    3: "It's a wooden door.",
    4: "It's a staircaise leading down.",
    5: "It's a beautiful wall decorated with gold.",
    7: "It's a Takhnar's (TM) vending machine.",
    8: "It's deadly lava, or magma, whatever.",
   11: "It's a wet dirt/stone cave wall.",
   12: "It's a solid wooden wall.",
  100: "It's a powerful waterfront. You're dead.",
  101: "Hey that's Oskar, Dark Mage. Scary guy. Nice abs though. 100000 HP"

}

lavanim = [' ','.','-',"'",'"',';','o']

ssheet = {
0: ('*',3),
1: ('Y',2),
2: ('0',3),
3: ('*',(CYAN,BLACK)),
4: ('*',2),
5: ('Q',3),
6: ('&',2),
7: ('%',3),
8: ('C',4),
9: ('o',0),
10:('.',2),
11:('=',10),
12:('E',0),
13:('8',2),
14:('E',2),
15:('s',3),

100: ('?',2),
101: ('?',3),
102: ('?',4),
103: ('?',3),
104: ('?',3),
105: ('?',10),
106: ('?',3),
107: ('?',18),

200: ('!',0),
201: (':',0),
202: (']',0),
203: ('\\',0),

225: ('"',18),

250: ('!',3),
251: (']',3),

900: ('l',0),
901: ('4',0)
}

if UNICODE:
    ssheet[1] = (u'⚶',2)

SPELL_FIRE = 0
SPELL_TELEPORT = 1
SPELL_SUICIDE = 2
SPELL_HEAL = 3
SPELL_GOLDEN = 4
SPELL_WATCH = 5
SPELL_SHOCKWAVE = 6
SPELL_THUNDER = 7
SPELL_TRANSMIGRATION = 8
SPELL_WINTER = 9

EL_FIRE = 0
EL_THUNDER = 1
EL_ICE = 2

def addchsafe(y,x,char,color):
    if(y in range(0,LV_H-1)):
        if x in range(0,LV_W-1):
            mypad.addch(y,x,char,color)

def elemental(t):
    global orientation
    if randint(0,3)==0:
    #   if DEBUG:
            #mess("DEBUG elemental of type "+str(t))
        oldor = [orientation[0],orientation[1]]
        if t==0:
            s=[ (-1,0) , (0,-1) ]
        elif t==1:
            s=[ (1,0) , (1,-1) ]
        elif t==2:
            s=[ (0,1) , (-1,1) ]

        d = choice(s)

        if DEBUG:
            mess("Step: "+str(d))
    
        orientation[0] += d[0]
        orientation[1] += d[1]
        if(orientation[0]+orientation[1]>4) or (not orientation[0] in range(0,5)) or (not orientation[1] in range(0,5)):
            if DEBUG:
                mess("OUT. "+str(oldor))
            orientation = [oldor[0],oldor[1]]

        if DEBUG:
            mess("orientation: " + str(orientation[0])+str(orientation[1]))

spellbook = [
[       [3,SPELL_TELEPORT,"Teleport"],      [2,SPELL_HEAL,"Heal"],      [3,SPELL_TRANSMIGRATION,"Transmigr."]   ],
[       [2,SPELL_SHOCKWAVE,"Shockwave"],    [4,SPELL_FIRE,"Fire"],      [6,SPELL_WINTER,"Winter"]       ],
[       [2,SPELL_THUNDER,"Thunder"],        [2,SPELL_WATCH,"Clairv."]                       ]
]

def spellrange(n):
    wand = 0
    for k in equip:
        if k[0][2]==OBJ_WAND:
            wand = 1
    diddly = {
        SPELL_THUNDER:8,
        SPELL_SHOCKWAVE:5,
        SPELL_FIRE:5,
        SPELL_WATCH:5*(wand==0) - (wand==1),
        SPELL_TRANSMIGRATION: (3 + 4*wand)
    }
    if n in diddly:
        return diddly[n]
    else:
        return -1

def spellcast(n):
    global entities, x, y, mxhp, hp, stage, waterfrozen, clairvoying, curss
    wand = 0
    for k in equip:
        if k[0][2]==OBJ_WAND:
            wand = 1

    if n==0: #fire spell
        mess("You cast a Fire Spell")
        elemental(EL_FIRE)
        count = 0
        for e in entities:
            if e[0] in range(x-5,x+6) and e[1] in range(y-5,y+6):
                hite(e,8*(1+wand) + atk//2  )
                count +=1
        if count>0:
            mess(str(count)+" enemies got burned by your spell")
        else:
            mess("... but there is noone to hurt.")
    elif n==1: #teleport
        elemental(1)
        if stage < 50:
            curss[CURS_TELEPORT] = wand*1 + (1-wand)*4
        else:
            mess("Surprisingly, you are unable to teleport...")
    elif n==2: #miscast
        hitp(60,True)
        mess("You miscast and hurt yourself (-60 HP)")
    elif n==3: #healing
        elemental(EL_ICE)
        s=(20 + randint(0,30*wand))*mxhp//100
        hp = min(mxhp,hp+s)
        mess("You cast a healing spell (+"+str(s)+" HP)")
    elif n==4: #coins
        s=randint(20,50)
        for i in range(0,s):
            xm = randint(x-4,x+5)
            ym = randint(y-4,y+5)
            if isfreepos(xm,ym):
                objects.append([xm,ym,OBJ_GOLD])
        mess("You make a large amount of coins materialize")
    elif n==5: #clairvoyance
        elemental(EL_THUNDER)
        if wand == 0:
            for i in range(max(0,x-5),min(x+6,LV_W-1)):
                for j in range(max(0,y-5),min(y+6,LV_H-1)):
                    floodfill(i,j)
        else:
            for i in range(0,LV_W):
                for j in range(0,LV_H):
                    floodfill(i,j)
        clairvoying = 2 + wand

        mess("You cast a clairvoyance spell.")

        for b in objects:
            if b[2] == OBJ_CHESTMONSTER and (abs(x-b[0])+abs(y-b[1]) < 15 ):
                b.identified = 1
                mess("A trap was revealed.")

    elif n==6: #shockwave
        mess("You cast a Shockwave Spell")
        count = 0
        for e in entities:
            if e[0] in range(x-5,x+6) and e[1] in range(y-5,y+6):
                nx = max(min(e[0]+randint(2,5+3*wand)*sgn(e[0]-x),LV_W-1),0)
                ny = max(min(e[1]+randint(2,5+3*wand)*sgn(e[1]-y),LV_H-1),0)
                if isnonsolid(lvl[nx][ny]):
                    e[0]=nx
                    e[1]=ny
                    count+=1
                else:
                    if randint(0,2) == 0:
                        hite(e,int((3 + atk//2)*(1+0.5*wand)))
                        count+=1
        if count>0:
            mess(str(count)+" enemies were affected by the wave")
        else:
            mess("... but there is noone to hurt.")

    elif n==7: # thunder spell
        count = []
        leclos = 100
        for i in range(0,len(entities)):
            e = entities[i]
            if (e[0] in range(x-8,x+9)) and (e[1] in range(y-8,y+9)) and (cansee(x,y,e[0],e[1])):
                count.append(i)

                        
        if len(count)>0:
            i = 0
            stdscr.addstr(0,3,"CHOOSE TARGET FOR THUNDER",color_pair(10))
            rays = [get_line(x,y,entities[e][0],entities[e][1]) for e in count]
            while True:
                for j in range(0,len(count)):
                    if j == i:
                        rcol = (' ',color_pair(16))
                    else:
                        rcol = ('.',color_pair(4))
                    for k in rays[j]:
                        mypad.addch(k[1],k[0],rcol[0],rcol[1])
                for j in range(0,len(count)):
                    e = entities[count[j]]
                    if j == i:
                        rcol = (' ',color_pair(16))
                    else:
                        rcol = ('.',color_pair(4))
                    mypad.addch(e[1],e[0],e[3],rcol[1])

                mypad.addch(y,x,'@',color_pair(16))

                blitlvl()
                flush_main()
                s = getchar()
                
                if s == KEYLEFT:
                    i=(i-1)%len(count)
                elif s == KEYRIGHT:
                    i=(i+1)%len(count)
                elif s == KEYENTER:
                    break

            #0 3 10

            tget = count[i]
            mess("You cast a Thunder Spell on the "+entities[tget][2]+str(leclos))
            hite(entities[tget],int((3+atk//2)*(1+wand)))

        else:
            mess("You cast a Thunder Spell that goes nowhere")      
#   elif n==7:
#       count = []
#       for e in entities:
#           if e[0] in range(x-8,x+9) and e[1] in range(y-8,y+9):
#               count.append(e)

#       tget = 

#       mess("You cast a Thunder Spell")
    
    elif n==8: #transmigration
        elemental(EL_THUNDER)
        trange = 3+4*wand
        stdscr.addstr(0,3,"CHOOSE DIRECTION FOR TRANSMIGRATION",color_pair(10))
        count = 0
        dc = -1
        while True:
            draw()
            mypad.addch(y,x,'@',color_pair(10))  
            '''for i in range(1,trange+1):
                addchsafe(y,x-i,' ',color_pair(13))
                addchsafe(y,x+i,' ',color_pair(13))
                addchsafe(y-i,x,' ',color_pair(13))
                addchsafe(y+i,x,' ',color_pair(13))
            for i in range(1,count+1):
            for i in range(1,count+1):
                if dc == 2:
                    addchsafe(y,x-i,' ',color_pair(14))
                if dc == 0:
                    addchsafe(y,x+i,' ',color_pair(14))
                if dc == 3:
                    addchsafe(y-i,x,' ',color_pair(14))
                if dc == 1:
                    addchsafe(y+i,x,' ',color_pair(14))    '''

            i = count
            if dc == 2:
                    addchsafe(y,x-i,'@',color_pair(2))
            if dc == 0:
                    addchsafe(y,x+i,'@',color_pair(2))
            if dc == 3:
                    addchsafe(y-i,x,'@',color_pair(2))
            if dc == 1:
                    addchsafe(y+i,x,'@',color_pair(2))
            

            blitlvl()
            flush_main()
            ccc = getchar()    
            if ccc == KEYDOWN:
                if dc != 1:
                    count = 0
                else:
                    count += 1
                dc = 1
            if ccc == KEYLEFT:
                if dc != 2:
                    count = 0
                else:
                    count+=1
                dc = 2
            if ccc == KEYUP:
                if dc != 3:
                    count = 0
                else:
                    count+=1
                dc = 3
            if ccc == KEYRIGHT:
                if dc != 0:
                    count = 0
                else:
                    count+=1
                dc = 0

            count = min(count,trange)
            if ccc == KEYENTER:
                dc = max(dc,0)
                break
        dirs = [ (1,0) , (0,1) , (-1,0), (0,-1) ]
        x += dirs[dc][0] * count
        y += dirs[dc][1] * count
        
        mess("You cast a Transmigration Spell")

        if (not isnonsolid(lvl[x][y])) or (lvl[x][y]==2):
            hp = 0
            mess("You fragged yourself.")

        for e in entities:
            if e[0] == x and e[1] == y:
                mess("You frag the "+e[2]+" (-50HP)")
                mess("You frag yourself (-50% HP)")
                hite(e,50)
                hitp(hp//2,True)

        #10 13 14   
    elif n == 9:
        mess("You cast a Winter Spell")
        mess("The whole dungeon becomes very cold...")
        waterfrozen = True
        for c in range(0, randint(1,3)):
            (gx,gy) = findfree()
            entities.append(IceTroll(gx,gy))

CURS_ICE = 0
CURS_POISON = 1
CURS_LOVE = 2
CURS_HALLUCINATION = 3
CURS_TELEPORT = 4
MAXCURS = 4

curses_names = {
    CURS_ICE:"Frozen",
    CURS_POISON:"Poisoned",
    CURS_LOVE:"In Love",
    CURS_HALLUCINATION:"Hallucinating",
    CURS_TELEPORT:"About to Teleport..."
}

curses_initial = ["F","P","L","H","T"]

curses_colors = {
    CURS_ICE:8,
    CURS_POISON:2,
    CURS_LOVE:4,
    CURS_HALLUCINATION:(MAGENTA,BLACK),
    CURS_TELEPORT:(BLACK,YELLOW)
}
    
catalogue = [
    [50,1,Item(OBJ_BOOK_BOTANY)],
    [40,1,Item(OBJ_BOOK_GEOGRAPHY)],
    [80,1,Plant(5,0,1)],
    [100,1,Plant(5,2,1)],
    [30,1,Item(OBJ_WAND)],      
    [70,1,Item(OBJ_SWORD_GOLDEN)]

]   
                        

#ATTRIBUTES
ATTRPOINTS = 2

ATTR_HAWK_EYE = 0
ATTR_STRONG_HANDS = 1
ATTR_DRAGONBORN = 2
ATTR_PIOUS = 3

attribute_strings = {
    ATTR_HAWK_EYE:("Hawk Eye","Extends the field of vision."),
    ATTR_STRONG_HANDS:("Strong Hands","Lowers probability of losing items in battle, increases probability of catching gnomes"),
    ATTR_DRAGONBORN:("Dragonborn","Half damage with lava"),
    ATTR_PIOUS:("Pious","Mana drops always yield +2")
    }

def exprofile(r):
    return int(r*4.9 + r*r*4.9//16)


if havecurses:
    curses.init_pair(0, curses.COLOR_WHITE,     curses.COLOR_BLACK)
    curses.init_pair(1, curses.COLOR_BLACK,     curses.COLOR_WHITE)     #1 black on white
    curses.init_pair(2, curses.COLOR_GREEN,     curses.COLOR_BLACK)     #2 green
    curses.init_pair(3, curses.COLOR_YELLOW,    curses.COLOR_BLACK)     #3 yellow
    curses.init_pair(4, curses.COLOR_RED,       curses.COLOR_BLACK)     #4 red
    curses.init_pair(5, curses.COLOR_BLACK,     curses.COLOR_YELLOW)    #5 black on yellow
    curses.init_pair(6, curses.COLOR_WHITE,     curses.COLOR_BLUE)  #white on blue
    curses.init_pair(7, curses.COLOR_YELLOW,    curses.COLOR_WHITE)     #yellow on white
    curses.init_pair(8, curses.COLOR_BLUE,      curses.COLOR_BLACK)     #blue on black
    curses.init_pair(9, curses.COLOR_WHITE,     curses.COLOR_RED)   #white on red
    curses.init_pair(10,curses.COLOR_MAGENTA,   curses.COLOR_BLACK)     #magenta
    curses.init_pair(11,curses.COLOR_WHITE,     curses.COLOR_YELLOW)    #white on yellow
    curses.init_pair(12,curses.COLOR_YELLOW,    curses.COLOR_RED)   #yellow on red
    curses.init_pair(13,curses.COLOR_BLACK,     curses.COLOR_MAGENTA)   #black on magenta
    curses.init_pair(14,curses.COLOR_MAGENTA,   curses.COLOR_GREEN) #magenta on green
    curses.init_pair(15,curses.COLOR_WHITE, curses.COLOR_BLUE)  #white on blue
    curses.init_pair(16,curses.COLOR_BLUE,  curses.COLOR_YELLOW)    #blue on yellow
    curses.init_pair(17,curses.COLOR_BLACK, -1)         #test
    curses.init_pair(18,curses.COLOR_CYAN,  curses.COLOR_BLACK) #cyan
    curses.init_pair(19,curses.COLOR_BLACK,     curses.COLOR_BLUE)      #black on blue

    STPAIR = 20

    for b in range(0,8):
        for f in range(0,8):
            curses.init_pair(STPAIR + 8*b + f, f, b)


C_WHITE = color_pair(1)
C_WHITERED = color_pair(9)
C_WHITEYELLOW = color_pair(11)
C_WHITEBLUE = color_pair(6)

if GRAPHIC:
    mypad = graphics.Pad(LV_W,LV_H) 
    back = graphics.Pad(WINX,WINY)
else:
    mypad = curses.newpad(LV_W,LV_H)
    back = curses.newwin(0,0)

flush_main()


#INIT

drawCount = 0

mxhp=100
hp=100
mana=0
manacount=0
speed = DEBUG*50
gold=0
rank=1
gems=[False]*50
slaindragons=0
exp=0
waterfrozen=False
arrows = 10
torch = [ [Item(-1),2000] ]
toggletorch = True
#if DEBUG:
    #    torch = []
curss = [0]*(MAXCURS+1)
spellsprog = [1,0,0] 
if DEBUG:
   curss[0:4] = [0,0,0,0]
orientation = choice([ [1,2] , [2,1] , [1,1] ])
ID = randint(0,999999999)


specialending = -1

name="ERROR"
dungeonname = choice ( [ "Ala", "Seth", "More", "Dath", "Kathra"]) + choice ( [ "go", "na" , "ka", "gu", "ni"]) + choice ( [ "r", "r", "dor"])
DEBUG_CHEST = [Item(OBJ_WAND), Carcass(4) , Item(OBJ_BOOK_WINTER) , Chestmonster(OBJ_BOOK_FIRE,0) , Chestmonster(OBJ_BOOK_FIRE,1) , Item(OBJ_SULFUR), Item(OBJ_HANDBOOK) ] 
inventory = [ Item(OBJ_BREAD) , Item(OBJ_LETTER) ] #+ DEBUG_CHEST 
if DEBUG: inventory+= DEBUG_CHEST
equip = [ ]

dialogue0 = [
(0,"I am {0}, I was sent from the King"),
(0,"I am here to murder you, Oskar."),
(1,"I salute you, {0}."),
(1,"I'm a little confused here, though."),
(1,"Because I was sent myself from His Majesty the King"),
(1,"To slay Aradach, the Spider Goddess, and free these tunnels from the Darkness"),
(1,"And annex them to the Reign"),
(0,"That's preposterous. Why would the King send me to murder his own knight?"),
(0,"Certainly you must be lying."),
(1,"Or you must be."),
(0,"I have a letter signed from the King himself."),
(1,"Can I take a look at that? I'm sure any murder can wait.")
]

dialogue1 = [
(0,"I... uhmm... I seem to have dropped it somewhere..."),
(1,"How convenient."),
(0,"I swear I had it from me..."),
(1,"This is the most vile of all the tricks Aradach has tried on me"),
(1,"A ghost, an image with the appearance of a warrior of the King."),
(1,"What I am about to do comes to me with the sweetest pleasure."),
(2,"Oskar stabs you."),
(2,"He moves the knife about in your stomach"),
(2,"You start bleeding uncontrollably."),
(1,"CAN YOU HEAR ME, ARADACH? I WILL HAVE YOUR HEAD, FOR THE KING!"),
(2,"You collapse. Everything goes dark.")
]

dialogue2 = [
(0,"Sure, here it is."),
(1,"Well, isn't this awkward..."),
(1,"This IS the signature of the King."),
(1,"...clearly someone is having a big fat laugh at us."),
(0,"So yeah, let me guess..."),
(1,"...there is no Spider Goddess..."),
(0,"...and no Dark Mage."),
(1,"There's just a knight who knows a bit to much..."),
(0,"...a dissident warrior he wants to get rid of..."),
(1,"...and a convenient system of caves, stuffed with holy emeralds"),
(1,"but also hostile creatures, which are expensive to eradicate."),
(1,"We are the cleaners to his emerald cave."),
(1,"I've been here a long time, searching for Aradach,"),
(1,"recognizing his eight-eyed grin in every shadow"),
(1,"and I was just slaving for the King"),
(1,"performing the duty of a peasant."),
(0,"We don't have much time. The dungeon is being quickly flooded."),
(1,"Oh."),
(0,"Oh what?"),
(1,"We are dead."),
(1,"The King has decided to drown us."),
(0,"You are quite the downer, you know that?"),
(1,"I'm quite the realist."),
(0,"I have an idea... but it's a shot in the dark."),
(2,"You hear the rumble of water entering the last floor..."),
(1,"Spare me the preamble and just try to save us."),
(2,"You cast a Teleportation Spell.")
]

#help panel
helppanel = [
"                                                                   ",
" ? or o             open this panel                                     ",
" arrows or hjkl     movement/attack                                     ",
" u                  use object from inventory (eat, equip, etc...)      ",
" d                  drop object from inventory/equipment                ",
" i                  info panel                                          ",
" c                  cast spell                                          ",
" a                  pick up item (right where you are)                  ",
" s                  skip turn                                           ",
" v                  toggle FOV dots (the annoying blue m*********ers)   ",
" p                  commit suicide (yes, you'll need this.)             ",
" q                  see messages history (arrow keys to navigate)       ",
" z                  sort inventory alphabetically                       ",
" x                  examine, look around, see enemy stats               ",
" t                  turn torch on/off (turning off costs 10 turns)      ",
"                                                                   "

]


#clues
clues = [
[
"                                                     ",
"      .-.---.,--.----,......     ,.---------------.  ",
"   ,.'warrior. We thought i'.-...- be extremely   |  ",
"  |   nice if you descended through the dark      |  ",
"   >  rooms of the deep dungeon of "+dungeonname.ljust(11) + "   <   ",
"  |   where --..--....,,-...dach, Queen of Sp.--.-'  ",
"   '-----'---''            '-----.-----.----'        "],

[
".---------------------------------------.",
"| An easy, tasty recipe!                |",
"| Ingredients:                          |",
"| * A meaty stramonium plant            |",
"| * a rock                              |",
"|     Difficuly: Easy                   |",
"|                                       |",
"| Smash the Stramonium with the stone.  |",
"| You're done!                          |",
"|                                       |",
"| Guaranteed to B L O W your mind!      |",
"`---------------------------------------'"
]
]


def finale():
    global name, inventory, OBJ_LETTER, alive, specialending
    hasletter = False
    for c in inventory:
        if c.ID == OBJ_LETTER:
            hasletter = True
    diag = dialogue0 + dialogue1
    if hasletter:
        diag = dialogue0 + dialogue2
        
    for l in diag:
        stdscr.clear()
        stdscr.addch(15,20,'@',color_pair(10))   
        stdscr.addch(15,23,'@',color_pair(0))
        stdscr.addstr(7,6,"                                             ")
        n = [name+": ","Oskar: ",""][l[0]]
        dcl = [color_pair(i) for i in [8,10,0]][l[0]]
        s1 = (n+l[1].format(name))[:50]
        s2 = ""
        if len(n+l[1])>50:
            s2 = (n+l[1])[50:]
        stdscr.addstr(7,6,s1,dcl)
        stdscr.addstr(8,6+len(n),s2,dcl)
        if l[0] == 2:
            mess(s1)
        #curses.napms(100)
        getchar()

    alive = False 
    if not hasletter:
        specialending = 0
    else:
        if sum(gems)>=40:
            specialending = 2
        else:
            mess("When you reach the surface, you are arrested")
            mess("by the guards of the king, and hanged.")
            specialending = 1
        

def additem(o):
    if len(inventory)<MAXINV:
        inventory.append(o)
        return True
    else:
        return False

atk=1
dfn=0



objects = []
entities = []

burndata = {
    OBJ_SULFUR:500,
    OBJ_WAND:12,
    OBJ_HANDBOOK:30,
    OBJ_PAPER:15,
    OBJ_PLANT:14, 
    OBJ_LETTER:50
}

for i in range(100,200): #books
    burndata[i] = 50

def addburn(o):
    global torch,toggletorch
    if not o.ID in burndata:
        mess("You can't burn that.")
        return False
    if len(torch)==0 or not o.sameas(torch[-1][0]):
       torch.append([o,burndata[o.ID]])
    else:
       torch[-1][1] += burndata[o.ID]
    mess("You burn the "+object_names(o)+" to fuel the torch")
    toggletorch = True
    return True

throwdata = {
    OBJ_STONE:10
}

def throw(o,tget):
    if o == -1:
        damage = 14
    else:
        damage = throwdata[o.ID]

    l = get_line(x,y,tget[0],tget[1])

    status = 0

    for p in l[1:]:
        for e in entities:
            if e[0:2] == list(p):
                hite(e,damage)
                status = 1
                break
        if status == 1:
            break
        if not iswalkable(p[0],p[1]):
            mess("The "+object_names(o)+" hits an obstacle.")
            status = 2
            break

    if status == 0:
        mess("The "+object_names(o)+" falls to the floor.")
               
                     
    

def hitp(force,ignoredef=False):
    global hp, dfn, equip
    if ignoredef:
        damage = force
    else:
        shield = 0
        for k in equip:
            if k[0][2] == OBJ_SHIELD:
                shield = 2
        for k in equip:
            if k[0][2] == OBJ_SHIELD_GOLDEN:
                shield = 4
        damage = force - randint(0,dfn+shield)
    damage = max(0,damage)
    hp=max(0,hp-damage)
    return damage

def dropshit(x,y,lv):
    global objects
    if lvl[x][y]!=8:
        value = randint(0,lv)
        lo = [0]
        if value <= 1:
            lo = [OBJ_GOLD]
        elif value <= 3:
            lo = ranplant()
        elif value <= 5:
            lo = [OBJ_HANDBOOK]
        elif value <= 6:
            lo = [choice(range(100,MAXBOOK))]
        elif value <= 9:
            lo = [choice(range(200,MAXARMOUR))]
        elif value <= 12:
            lo = [choice(range(250,MAXGOLDEN))]
        else:
            lo = [OBJ_GOLD]
        objects.append([x,y]+lo)

def hite(e,force):
    global slaindragons
    if e[2] == "Gnome":
        return
    damage = max(0,force-randint(0,e[5]))
    e[6] = max(0,e[6]-force)
    if(e[6]<=0):
        mess("The "+e[2]+" is dead.")
        e.brain.deadMessage()
        if (e[3] in range(ord('a'),ord('z')+1)):
            if randint(0,5)==0:
                dropshit(e[0],e[1],e[3]-ord('a'))
            elif randint(0,8)==0:
                #dropcarcass
                objects.append(Carcass(e[3] - ord('a'), e[0], e[1]))
        if (e[2] == "Fairy"):
            if lvl[x][y]!=8:
                objects.append(Item(OBJ_FAIRY_LIVER,e[0],e[1]))
        if (e[2] == "Dragon"):
            if lvl[x][y]!=8:
                objects.append(Item(OBJ_DRAGON_SCALES,e[0],e[1]))
            slaindragons += 1
                
        entities.remove(e)
        givexp(e[7])
    else:
        if(damage>0):
            mess("The "+e[2]+" was hit. (-"+str(damage)+" HP)")
        else:
            mess("You missed the "+e[2])

        e.brain.hitMessage()


def givexp(amt):
    global exp, rank, atk, dfn, mxhp, hp, speed
    exp += amt
    lepl = False
    while(exp >= exprofile(rank)):
        exp-=exprofile(rank)
        rank+=1
        atk += (1 + rank//10)*(not gender) + (min(randint(0,3),1) + rank//10)*gender
        dfn+=(rank+3)//7
        oldhp = mxhp
        mxhp+=3 + rank**2//17
        hp = (hp*mxhp)//oldhp
        speed+=1
        lepl=True
    if(lepl):
        mess("Welcome to level "+str(rank))

def iswall(cx,cy):
    if((cx<0)or(cy<0)or(cx>=LV_W)or(cy>=LV_H)):
        return False
    return lvl[cx][cy] in [1,3,4,5,7,11,12]
 

def isfreepos(cx,cy):
    if((cx<0)or(cy<0)or(cx>=LV_W)or(cy>=LV_H)):
        return False
    s = True
    global x,y

    if ((x==cx) and(y==cy)):
        s = False
    for e in entities:
        if ((e[0]==cx) and(e[1]==cy)):
            s = False
    for o in objects:
        if ((o[2]) in solids):
            if ((o[0]==cx)and(o[1]==cy)):
                s = False

    return (s and isfree(lvl[cx][cy]))

def iswalkable(cx,cy):
    if((cx<0)or(cy<0)or(cx>=LV_W)or(cy>=LV_H)):
        return False
    s = True
    global x,y

    if ((x==cx) and(y==cy)):
        s = False
    for e in entities:
        if ((e[0]==cx) and(e[1]==cy)):
            s = False
    for o in objects:
        if ((o[2]) in solids):
            if ((o[0]==cx)and(o[1]==cy)):
                s = False

    return (s and isnonsolid(lvl[cx][cy]))

def isfrees(qx,qy):
    return isfree(lvl[qx][qy])

def ispathable(num):
    return (num in [0,3,8])

'''def cansee(xa,ya,xb,yb):
    x1=min(xa,xb)
    x2=max(xa,xb)
    y1=min(ya,yb)
    y2=max(ya,yb)
    clear1=True
    for x in range(x1,x2+1):
        clear1 = clear1 and isnonsolid(lvl[x][y1])
    for y in range(y1,y2+1):
        clear1 = clear1 and isnonsolid(lvl[x2][y])

    clear2=True
    for y in range(y1,y2+1):
        clear2 = clear2 and isnonsolid(lvl[x1][y])
    for x in range(x1,x2+1):
        clear2 = clear2 and isnonsolid(lvl[x][y2])
    
    return clear1 or clear2 '''

def cansee(xa,ya,xb,yb):
    if (xa==xb) and (ya==yb):
        return True
    s = True
    for sp in get_line(xa,ya,xb,yb):
        if not (sp in [(xa,ya),(xb,yb)]): 
            if not isnonsolid(lvl[sp[0]][sp[1]]):
                return False
    return True


messages=[("the adventure begins",0)]
def mess(strin,col=0):
    if False: #len(messages)>=5:
        messages.pop(0)
    messages.append([strin,col])

def findfree():
    global lvl
    gx = 0
    gy = 0
    safe = 0
    while not isfree(lvl[gx][gy]) and safe < 400:
        gx = randint(0,LV_W-1)
        gy = randint(0,LV_H-1)
        safe+=1
    return (gx,gy)

fog = []
def floodfill(xs,ys,ite=-1,force=False):
    if (xs < 0) or (xs>=LV_W) or (ys < 0) or (ys>=LV_H):
        return
    if ite==0:
        return
    if ite==-1:
        nex=-1
    else:
        nex=ite-1
    
    if fog[xs][ys] != 0 and not force:
        return
    fog[xs][ys] = 1
    if isnonsolid(lvl[xs][ys]):
        floodfill(xs+1,ys,nex)
        floodfill(xs-1,ys,nex)
        floodfill(xs,ys-1,nex)
        floodfill(xs,ys+1,nex)
        floodfill(xs+1,ys+1,nex)
        floodfill(xs-1,ys+1,nex)
        floodfill(xs-1,ys-1,nex)
        floodfill(xs+1,ys-1,nex)

con = []
def confloodfill(xs,ys,ite=-1):
    global con
    if (xs < 0) or (xs>=LV_W) or (ys < 0) or (ys>=LV_H):
        return
    if ite==0:
        return
    if ite==-1:
        nex=-1
    else:
        nex=ite-1
    
    if con[xs][ys] != 0:
        return
    con[xs][ys] = 1
    if ispathable(lvl[xs][ys]):
        confloodfill(xs+1,ys,nex)
        confloodfill(xs-1,ys,nex)
        confloodfill(xs,ys-1,nex)
        confloodfill(xs,ys+1,nex)
        confloodfill(xs+1,ys+1,nex)
        confloodfill(xs-1,ys+1,nex)
        confloodfill(xs-1,ys-1,nex)
        confloodfill(xs+1,ys-1,nex)


def fag(xp,yp):
    global x,y
    return fog[xp][yp]# ( (xp in range(x-4,x+4)) and (yp in range(y-4,y+4)))

FOV_RADIUS = 10

dungeon =  ["###########################################################",
            "#...........#.............................................#",
            "#...........#........#....................................#",
            "#.....................#...................................#",
            "#....####..............#..................................#",
            "#.......#.......................#####################.....#",
            "#.......#...........................................#.....#",
            "#.......#...........##..............................#.....#",
            "#####........#......##..........##################..#.....#",
            "#...#...........................#................#..#.....#",
            "#...#............#..............#................#..#.....#",
            "#...............................#..###############..#.....#",
            "#...............................#...................#.....#",
            "#...............................#...................#.....#",
            "#...............................#####################.....#",
            "#.........................................................#",
            "#.........................................................#",
            "###########################################################"]

def lightsource(cx,cy):
    global lvl,objects,entities,LV_W,LV_H
    if not ((cx in range(0,LV_W)) and (cy in range(0,LV_H))):
        return False
    if lvl[cx][cy] in luminescent:
        return True
    
lightradius = 0

class Map(object):
    # Multipliers for transforming coordinates to other octants:
    mult = [
                [1,  0,  0, -1, -1,  0,  0,  1],
                [0,  1, -1,  0,  0, -1,  1,  0],
                [0,  1,  1,  0,  0, -1, -1,  0],
                [1,  0,  0,  1, -1,  0,  0, -1]
            ]
    def __init__(self):
        global LV_W,LV_H
        self.width, self.height = LV_W,LV_H
        self.light = []
        for i in range(self.height):
            self.light.append([0] * self.width)
        self.flag = 0
    def square(self, x, y):
        global lvl
        return lvl[x][y]
    def blocked(self, x, y):
        global lvl
        if (lvl[x][y] in [100]): #transparent tiles
            return False
        return (x < 0 or y < 0
                or x >= self.width or y >= self.height
                or (not isnonsolid(lvl[x][y]))
                    )
    def visible(self, cx, cy):
        global fow,x,y,lvl,clairvoying,attributes

        
        return self.light[cy][cx] == self.flag

    def litt(self,cx,cy):
        global lvl,objects,entities,x,y,NLUT,lightradius
        ret = False

       

        if (cx-x)**2 + (cy-y)**2 <= (lightradius**2)+1:
            return True

        if lightsource(cx,cy):
            return True

        nbd = [ (cx + n[0],cy + n[1]) for n in NLUT]
        for n in nbd:
            if lightsource(n[0],n[1]):
                return True


        return False

    def lit(self, cx, cy):
        global fow,x,y,lvl,clairvoying,attributes
        if clairvoying == 1:
         if (cx-x)**2 + (cy-y)**2 <= (20)**2:
             return True
         else:
            return False
        elif clairvoying >= 2:
            return True


        return  self.visible(cx,cy) and self.litt(cx,cy)


    def set_lit(self, x, y):
        if 0 <= x < self.width and 0 <= y < self.height:
            self.light[y][x] = self.flag
    def _cast_light(self, cx, cy, row, start, end, radius, xx, xy, yx, yy, id):
        "Recursive lightcasting function"
        if start < end:
            return
        radius_squared = radius*radius
        for j in range(row, radius+1):
            dx, dy = -j-1, -j
            blocked = False
            while dx <= 0:
                dx += 1
                # Translate the dx, dy coordinates into map coordinates:
                X, Y = cx + dx * xx + dy * xy, cy + dx * yx + dy * yy
                # l_slope and r_slope store the slopes of the left and right
                # extremities of the square we're considering:
                l_slope, r_slope = (dx-0.5)/(dy+0.5), (dx+0.5)/(dy-0.5)
                if start < r_slope:
                    continue
                elif end > l_slope:
                    break
                else:
                    # Our light beam is touching this square; light it:
                    if dx*dx + dy*dy < radius_squared:
                        self.set_lit(X, Y)
                    if blocked:
                        # we're scanning a row of blocked squares:
                        if self.blocked(X, Y):
                            new_start = r_slope
                            continue
                        else:
                            blocked = False
                            start = new_start
                    else:
                        if self.blocked(X, Y) and j < radius:
                            # This is a blocking square, start a child scan:
                            blocked = True
                            self._cast_light(cx, cy, j+1, start, l_slope,
                                             radius, xx, xy, yx, yy, id+1)
                            new_start = r_slope
            # Row is scanned; do next row unless last square was blocked:
            if blocked:
                break
    def do_fov(self, x, y, radius):
        "Calculate lit squares from the given location and radius"
        self.flag += 1
        for oct in range(8):
            self._cast_light(x, y, 1, 1.0, 0.0, radius,
                             self.mult[0][oct], self.mult[1][oct],
                             self.mult[2][oct], self.mult[3][oct], 0)

def _checkfow(a,b): # DEPRECATED!
    global fow,x,y,lvl,clairvoying,attributes

    if clairvoying == 1:
        if (a-x)**2 + (b-y)**2 <= (20)**2:
            return True
        else:
            return False
    elif clairvoying == 2:
        return True

    if not fag(a,b):
        return False

    if lvl[a][b] == 2:
        return False
    if (a-x)**2 + (b-y)**2 >= (11 + attributes[ATTR_HAWK_EYE]*5)**2-1:
        return False
    else:
        return cansee(x,y,a,b)
    

    if fow[a][b] == 2:
        return 1
    elif fow[a][b] == 1:
        return 0
    else:
        s = True
        for p in get_line(x,y,a,b):
            if isnonsolid(lvl[p[0]][p[1]]):
                fow[p[0]][p[1]] = 2
            else:
                #fow[p[0]][p[1]] = 1
                s = False
                break
        return s

def ranplant():
    r = (0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,2,2,3,3,3,3,4,4,5)
    return Plant(randint(0,4),choice(r),randint(0,3)//3)


dada =[
"Play as default character",
"Create new character",
"Credits",
"Quit"
]

n = 0
menu = True
while menu:
    if DEBUG and GRAPHIC:
        print("Printing menu...")
    stdscr.clear()
    ppp = 3
    for l in title:
        for i in range(0,len(l)):
            ttlc = color_pair(0)
            stdscr.addch(ppp,8+i,l[i],ttlc) 
        ppp+=1

    for i in range(0,len(dada)):
        if n==i:
            sscc = color_pair(1)
            zibi = "*"
        else:
            sscc = color_pair(0)
            zibi = ""
        stdscr.addstr(12+i,7,zibi+dada[i],sscc)

    if DEBUG and GRAPHIC:
        sys.stdout.write("Flushing...")
        sys.stdout.flush()

    flush_main()

    if DEBUG and GRAPHIC:
        sys.stdout.write("getchar()...")
        sys.stdout.flush()


    key = getchar()

    if DEBUG and GRAPHIC:
        sys.stdout.write(str(key))
        sys.stdout.flush()


    if key in [KEYDOWN,ord('j')]:
        n=(n+1)%len(dada)
    elif key in [KEYUP,ord('k')]:
        n=(n-1)%len(dada)
    elif key == KEYENTER:
        if n == 0:
            menu = False
            name = "Sasellor"
            gender = 0
            spellsprog = [1, 0, 0]
            attributes = [1,1,0,0]
        elif n==1:
            
            m = 0
            stuff = [
            "Name",
            "Gender",
            "First Spell",
            "Attributes",
            "Done"
            ]
            cock = True
            gender = 0
            name = ""
            fspell = 0
            attributes = [0] * len(attribute_strings)
            while cock:
                stdscr.clear()
                for j in range(0,len(stuff)):
                    if m == j:
                        cacol = color_pair(1)
                    else:
                        cacol = color_pair(0)
                    stdscr.addstr(1+j,1,stuff[j],cacol)

                stdscr.addstr(1,15,name)
                stdscr.addstr(2,15,["M","F"][gender])
                stdscr.addstr(3,15,spellbook[fspell][0][2])

                i = 0
                for j in range(0,len(attribute_strings)):
                    if attributes[j]:
                        stdscr.addstr(1+i,27," "+attribute_strings[j][0])
                        i+=1


                flush_main()
                keyy = getchar()

                if keyy == KEYDOWN:
                    m=(m+1)%len(stuff)
                elif keyy == KEYUP:
                    m=(m-1)%len(stuff)
                elif keyy == KEYENTER: 
                    if m==len(stuff)-1:
                        spellsprog = [0]*3
                        spellsprog[fspell] = 1
                        menu = False
                        cock = False
                    if m==0:
                        stdscr.addstr(1,15,"_"*10)
                        curses.echo()
                        name = stdscr.getstr(1,15,10)
                        curses.noecho()
                    if m==1:
                        gender = not gender
                    if m==2:
                        fspell = (fspell+1)%3
                    if m==3:
                        g = 0
                        while True:
                            for i in range(0,len(attribute_strings)):
                                if attributes[i]:
                                    cola = color_pair(0)
                                else:
                                    cola = color_pair(8)
                                stdscr.addstr(1+i,27," "+attribute_strings[i][0],cola)
                            stdscr.addch(1+g,27,'*')
                            stdscr.addstr(3+len(attribute_strings),28,str(ATTRPOINTS - sum(attributes)) + " attribute points left.")
                            
                            stdscr.addstr(15,2," "*50)
                            stdscr.addstr(15,2,attribute_strings[g][1])
                            flush_main()
                            zzz = getchar()
                            if zzz == KEYDOWN:
                                g = (g+1)%len(attribute_strings)
                            if zzz == KEYUP:
                                g = (g-1)%len(attribute_strings)
                            if zzz == KEYENTER:
                                attributes[g] = not attributes[g]
                                if sum(attributes) > ATTRPOINTS:
                                    attributes[g] = not attributes[g]
                            if zzz == KEYLEFT:
                                break
                                

        elif n==2:
            stdscr.clear()
            for j in range(0,len(credits)):
                stdscr.addstr(j,0,credits[j])
            for j in range(0,len(creditsred)):
                addstrtrans(stdscr,j,0,creditsred[j],color_pair(4))
            for j in range(0,len(creditsyellow)):
                addstrtrans(stdscr,j,0,creditsyellow[j],color_pair(3))
            #stdscr.addch(3,8,'#',color_pair(1))
            #stdscr.addch(3,10,'#',color_pair(1))
            flush_main()
            getchar()
        elif n==3:
            curses.nocbreak()
            if MODE != 2:
                stdscr.keypad(0)
            curses.echo()
            curses.endwin()
            exit()


            
    
'''stdscr.addstr(12,5,"Input your name (Press Enter for random name):")
flush_main()
curses.echo()
name = stdscr.getstr(14,6,10)
curses.noecho()'''

def updateCam(cx = None, cy = None):
    global camx,camy,x,y,LW_W,LW_H
    if cx == None:
       cx = x
    if cy == None:
       cy = y
    camx = min(max(0,cx-LW_W//2),LV_W-LW_W-1)
    camy = min(max(0,cy-LW_H//2),LV_H-LW_H-2)



def draw():
        global lvl,x,y,entities,objects,fow,fog,tset,ssheet,BXCHARS,mana,hp,mxhp,gold,gems,curss,inventory,equip,stage,rank,atk,dfn,attributes, clairvoying, lightradius, turns, drawCount

        #DISPLAY / DRAW

        drawCount += 1

        #do fow
        '''fow = [[0]*LV_H]*LV_W

        for i in range(0,LV_W):
            for j in range(0,LV_H):
                fow[i][j] = 0

#       for i in range(x-1,x+2):
#           for j in range(y-1,y+2):
#               fow[i][j] = 2'''

        fovradius = 11 + attributes[ATTR_HAWK_EYE]*5

        if len(torch)>0 and toggletorch:
            lightradius = 13
        else:
            lightradius = 1

        fovBrain.do_fov(x,y,fovradius)
        

        #draw level draw map display level display map
        
        visdotchar = '.'
        if UNICODE:
            visdotchar = u'⋅'


        mypad.erase()
        for i in range(max(0,camx),min(1+camx+LW_W,LV_W)):
            for j in range(max(0,camy),min(1+camy+LW_H,LV_H-1)):
                if not fag(i,j):
                    if fovBrain.lit(i,j):
                        fog[i][j] = 1
                if fag(i,j):
                    sbd = tset[lvl[i][j]][1]
                    tilecol = color_pair(sbd)
                    if iswall(i,j) and fovBrain.lit(i,j) == False: #blue outside fov
                        if lvl[i][j] in [3,4,7]: #special tiles for blue-on-black
                            cccc = color_pair(8)
                        else: #else, black on blue
                            cccc = color_pair(19)
                        mypad.addch(j,i,hall_char(tset[lvl[i][j]][0]),hall_floor_color(cccc))
                    
                    elif visibility_dots and lvl[i][j] == 0:
                            if fovBrain.lit(i,j):
                                mypad.addstr(j,i,hall_floor(visdotchar),hall_floor_color(color_pair(8)))
                    elif UNICODE and lvl[i][j] == 1:
                        total = iswall(i+1,j) + 2*iswall(i,j-1) + 4*iswall(i-1,j) + 8*iswall(i,j+1)
                        mypad.addstr(j,i,WALLS[total][0].encode('utf-8'),color_pair(WALLS[total][1]))
                    else:
                        if fovBrain.lit(i,j):
                            if lvl[i][j] == 100 and waterfrozen:    
                                mypad.addch(j,i,hall_char('/') , hall_color(color_pair(15)))
                            elif lvl[i][j] == 8:
                                
                                val = int(simplex.scaled_raw_noise_3d(0,7, float(i)/3,float(j)/3, float(drawCount)/3))%len(lavanim)
                                mypad.addch(j,i,hall_char(lavanim[val]),hall_color(tilecol))

                            else:
                                mypad.addstr(j,i,hall_char(tset[lvl[i][j]][0]) , hall_color(tilecol)  )
                                
                else:
                    mypad.addch(j,i,' ',color_pair(0))


                #if DEBUG and lvl[i][j] == 0 and not con[i][j] == 1:
                #    mypad.addch(j,i,'+')
        #draw objects
        for o in objects:
            if fog[o.x][o.y] and fovBrain.lit(o.x,o.y):
#                   if o[2] == OBJ_CHESTMONSTER and o[3] == 0:
#                       mypad.addch(o[1],o[0],ssheet[o[4]][0], color_pair( ssheet[o[4]][1]))
#                   elif o[2] == OBJ_CARCASS:
#                       mypad.addch(o[1],o[0],chr(ord('a')+o[3]),color_pair(0))
#                   else:
                        mypad.addstr(o.y,o.x,hall_char(o.sprite()), hall_color(color_pair(o.colour())))  
        
        #draw entities
        for e in entities:
            if fog[e[0]][e[1]] and fovBrain.lit(e[0],e[1]):
                if lvl[e[0]][e[1]] == 8:
                    c=color_pair(12)
                else:
                    if not e.visible():
                       continue
                    if isinstance(e,Gnome):
                        c = color_pair(2)
                    else:
                        c = color_pair_fb(RED,BLACK) 

                addchsafe(e[1],e[0],hall_char(e[3]), hall_color(c))
                if isinstance(e,Dragon):
                    if e.brain.particles == -1:
                        mypad.addch(e[1]+e.brain.by,e[0]+e.brain.bx,hall_char('~'),hall_color(color_pair(0)))
                    elif e.brain.particles > 0:
                        for i in range(1,1+e.brain.particles):
                            mypad.addch(e[1]+e.brain.by*i,e[0]+e.brain.bx*i,hall_char('*'),hall_color(color_pair(4)))

        #draw character
        if lvl[x][y] == 8:
            c=color_pair(9)
        elif curss[CURS_POISON]>0:
            c=color_pair(2)
        elif curss[CURS_LOVE]>0:
            c=color_pair(4)
        elif curss[CURS_ICE]>0:
            c=color_pair(8)
        else:
            c=color_pair_fb(WHITE,BLACK) 

        mypad.addch(y,x,'@',c)


        #border
        back.erase()
        back.addch(0,0,BXCHARS[0])
        back.addch(0,LW_W+2,BXCHARS[6])
        back.addch(LW_H+2,0,BXCHARS[2])
        for i in range(0,LW_W+1):   
            back.addch(0,i+1,BXCHARS[5])
        for i in range(0,LW_W+1):
            back.addch(LW_H+2,i+1,BXCHARS[5])
        for i in range(0,LW_H+1):
            back.addch(i+1,0,BXCHARS[4])
            back.addch(i+1,LW_W+2,BXCHARS[4])
        for i in range(0,25):
            back.addch(i+1,LW_W+25,BXCHARS[4])
        back.addch(LW_H+2,LW_W+2,BXCHARS[3])
        back.addch(25,LW_W+25,BXCHARS[3])
        if DEBUG:
            back.addstr(0,3,"DEBUG MODE",color_pair(10))

        #info
        back.addstr(LW_H+3,1, "HP "+str(hp)+"/"+str(mxhp))  
        back.addstr(LW_H+3,14, "G "+str(gold), color_pair(3))
        if mana>0:
            back.addstr(LW_H+3,25, "Mana: "+str(mana), color_pair(8))
        if gems[stage-1]:
            back.addstr(LW_H+3,21, "EF!", color_pair(2))
        ct=0
        for m in reverse(messages[-5:]):
            lecol=color_pair(m[1])
            back.addstr(LW_H+6+ct,1, m[0], lecol)
            ct+=1

        back.addstr(LW_H+2,7,"*FLOOR "+str(stage)+" - "+dtypenames[dtype] +"*")
        if speed > 0:
            back.addstr(LW_H+2,LW_W-10, "%s MOVES"%turns,color_pair_fb(WHITE,BLACK))

        for i in range(LW_W+3,LW_W+3+22):
            back.addch(0,i,BXCHARS[5])
        back.addch(0,LW_W+3+22, BXCHARS[1])
        back.addstr(1,LW_W+4, name)
        cs = 0
        for c in range(0,len(curss)):
            if curss[c]>0:
                if curss[c] > 9:
                    ster = "+"
                else:
                    ster = str(curss[c])

                back.addstr(1,LW_W+15+cs,ster,color_pair(curses_colors[c]))
                cs+=1

        back.addstr(1,LW_W+19, "LV "+str(rank).zfill(2))
        back.addch(1,LW_W+25,BXCHARS[4])

        for j in range(LW_W+3,LW_W+25):
            back.addch(6,j,BXCHARS[5])
            back.addch(2,j,BXCHARS[5])
        for k in [2,6]:
            back.addch(k,LW_W+2,BXCHARS[9])
            back.addch(k,LW_W+25,BXCHARS[8])
        back.addstr(6,LW_W+2+8, "INVENTORY")
        for i in range(0,len(inventory)):
            s = object_names(inventory[i])[:INVCLIP]

            back.addstr(7+i,LW_W+4, s, color_pair(inventory[i].colour() ))

        back.addstr(2,LW_W+2+8,"EQUIPMT")

        for i in range(0,len(equip)):
            back.addstr(3+i,LW_W+4, object_names(equip[i][0])[:INVCLIP])

        back.addstr(LW_H+4,1,"ATK %s DEF %s SPD %s"%(atk,dfn,speed))

        if waterlvl >= WATSTEPS:
            back.addstr(LW_H+4,24, "Water to floor "+str(waterlvl//WATSTEPS))

        if len(torch) == 0:
            tstr = "OFF"
        else:
            tstr = ""
            for f in torch:
                if f[0].ID == -1:
                    tstr += "Oil"
                else:
                    tstr += object_names(f[0])[:7]
                tstr += " (%s) "%f[1]

        if len(tstr)>40:
            tstr = "[...] "+tstr[-35:]

        back.addstr(LW_H+12,1,"Torch: ")

        if len(torch) == 0:
            back.addstr(LW_H+12, 8, "OFF")
        else:
            xox = 8
            for f in torch:
                if f[0].ID == -1:
                    back.addstr(LW_H+12,xox,"Oil",color_pair_fb(WHITE,BLACK))
                    xox += 4
                else:
                    back.addch(LW_H+12,xox,f[0].sprite(),color_pair(f[0].colour()))
                    xox += 2
            back.addstr(LW_H+12,xox,"(%s)"%sum([ f[1] for f in torch  ]) , color_pair_fb(WHITE,BLACK))

        blitback()
        blitlvl()
    
#       flush_main()

def dopturn(cmd):

        global x,y,hp,mxhp,gold,mana,lvl,entities,ssheet,tset,objects,inventory,equip,waterlvl,atk,dfn,stage,rank,attributes,alive,crawlin,visibility_dots,camx,camy,fovBrain,clairvoying,toggletorch

        turn = False

        toosick=False
        if curss[CURS_POISON] == 1:
            toosick=True
            mess("You puke. (-20 HP)",4)
            objects.append(Item(OBJ_PUKE,x,y))
            hitp (20,True)
            return True

        if curss[CURS_POISON] and randint(0,max(0,200-curss[CURS_POISON])//50) == 0:
            toosick=True
            mess("You feel sick and can't move",2)
            return True

        if curss[CURS_ICE] > 0:
            if cmd in [KEYUP,KEYDOWN,KEYLEFT,KEYRIGHT]:
                if randint(0,1):
                    mess("Way too cold. Not doing that.")
                else:
                    mess("You're frozen, so there's that.")
                return False

        if curss[CURS_ICE] <= 0 and not toosick:
            nx = x
            ny = y
            hasmoved = 0
            if  cmd in [KEYDOWN,ord('j')]:
                ny = min(y+1,LV_H-2)
                hasmoved = 1
            elif cmd in [KEYUP,ord('k')]:
                ny = max (0,y-1)
                hasmoved = 1
            elif cmd in [KEYLEFT,ord('h')]:
                nx = max (0,x-1)
                hasmoved = 1
            elif cmd in [KEYRIGHT,ord('l')]:
                nx = min(x+1,LV_W-1)
                hasmoved = 1
            if hasmoved:
                if isnonsolid(lvl[nx][ny]):
                  1# floodfill(nx,ny)

                                
                for e in entities: #hit entities hit enemy
                    if( (e[0]==nx) and (e[1]==ny)):

                        if isinstance(e,Gnome) and e.brain.state != GN_DONE:
                            if (len(inventory)<MAXINV) and  (randint(0,2) + (not attributes[ATTR_STRONG_HANDS]))<1:
                                mess("You catch a Gnome")
                                inventory.append(GnomeItem(e))
                                entities.remove(e)
                                return True 
                            else:
                                mess("The Gnome slips from your hands.")
                                return True

                        elif ( e[3] == "Succubus")  and curss[CURS_LOVE] > 0:
                            mess("You are unable to hit the Succubus")
                            return False


                        elif isinstance(e,Meanie):
                            tpow = atk
                            for k in equip:
                                if k[0].ID == OBJ_SWORD:
                                    tpow = (atk * 3)//2
                            for k in equip:
                                if k[0].ID == OBJ_SWORD_GOLDEN:
                                    tpow = (atk * 5)//2
                            hite(e,tpow)
                            return True
                        else:
                            return False


                if lvl[nx][ny] == 3: #open doors
                    lvl[nx][ny] = 0
                    mess("You open the door.")
                    #floodfill(nx,ny,-1,True)
                    return True
                if lvl[nx][ny] == 4: #exit
                    crawlin = False
                    mess("You descend the stairs...")
                    return True

                if lvl[nx][ny] == 7: #vending machine

                    exitgiftshop=True
                    while exitgiftshop:
                        stdscr.clear()
                        ppp = 1
                        for l in vendingback:
                            stdscr.addstr(ppp,1,l,color_pair(0))
                            ppp+=1 
                        stdscr.addstr(1,7,"THAKNAR's - GIFT SHOP")

                        lei = 1
                        for v in vmachset:
                            if(v[0] <= gold):
                                j = 0
                            else:
                                j = 4
    
                            s = "ERROR"
                            if v[1] == 0:
                                s = "Gold plate it!"
                            elif v[1] == 1:
                                s = object_names(v[1])
                            stdscr.addstr(lei + 3,6,str(lei) + ") "+ (goodstring(s)) + str(v[0])+"* ", color_pair(j))
                            lei+=1
                        stdscr.addstr(11,3,vmachword[0])
                        stdscr.addstr(12,3,vmachword[1])


                        flush_main()
                        rrrr=getchar()
                        if rrrr in [KEYENTER]:
                            exitgiftshop=False
                        elif rrrr in range(ord('1'),ord('1')+len(vmachset)):
                            ind = rrrr-ord('1')
                            if vmachset[ind][1] == 0:
                                stdscr.clear()
                                stdscr.addstr(1,1,"Choose an item to gold plate")
                                getchar()
                            if vmachset[ind][1] == 1:
                                if gold >= vmachset[ind][0]:
                                    b = color_pair(5)
                                    if len(inventory)<MAXINV:
                                        gold -= vmachset[ind][0]
                                        inventory.append(vmachset[ind][2])
                                        stdscr.addstr(3,4,"+----------------------+",b)
                                        stdscr.addstr(4,4,"*    Good choice!      *",b)
                                        stdscr.addstr(5,4,"*Thanks for stopping by*",b)
                                        stdscr.addstr(6,4,"+----------------------+",b)
                                    else:
                                        stdscr.addstr(4,6,"+---------------+",b)
                                        stdscr.addstr(5,6,"|Inventory full.|",b)
                                        stdscr.addstr(6,6,"+---------------+",b)
                                    flush_main()
                                    getchar()
                    
                    return False
   

                if lvl[nx][ny] == 101: #finale
                    finale()
                    return True

                if iswalkable(nx,ny):
                    x = nx
                    y = ny
                    turn=1  
                    return True

        #f button throw

        if cmd == ord('f') and DEBUG:
            throw(Item(OBJ_STONE),(x+10,y))
            return True

        if cmd == ord('t'):
            if len(torch)<=0:
               mess("There is no fuel in the torch.")
               return False
            toggletorch = not toggletorch
            if toggletorch:
               mess("You light your torch")
            else:
               if torch[-1][1] <= 10:
                  del torch[-1]
               else:
                  torch[-1][1] -= 10
               mess("You extinguish the torch")
            return True

        #b button burn

        if cmd == ord('b') and DEBUG:
            istoburn=False
            for i in inventory:
                if i.ID in burndata:
                    istoburn=True
            mess("You have nothing to burn.")


        #x button examine
        if cmd == ord('x'):
            if curss[CURS_HALLUCINATION]>0:
                mess("You are way too high for that.",(YELLOW,BLACK))
                return False
            cursor = [x,y]
            showpath = 0
            vobj = [k for k in entities + objects if (fovBrain.lit(k[0],k[1]) or ([k[0],k[1]] == [x,y])) ]
            point = 0               

            vobj.sort(key = lambda k :  LV_W*k[1] + k[0] )

            path = []

            while True:

                text = []
                if cursor == [x,y]:
                    text.append("That's you, the hero.")
                    doents = True
                elif fovBrain.lit(cursor[0],cursor[1]):
                    if lvl[cursor[0]][cursor[1]] in xaminetiles:
                        if lvl[cursor[0]][cursor[1]] == 100 and waterfrozen:
                            text.append("The water wave has rapidly frozen in a huge, shiny, silent mass of cold ice.")
                        else:
                            text.append(xaminetiles[lvl[cursor[0]][cursor[1]]])
                    doents = True
                else:
                    text = ["This place is not visible or too dark from your viewpoint."]
                    doents = False

                

                if doents:
                    for e in entities:
                        if [e[0],e[1]] == cursor and e.visible():
                            text.append(e.getLongStr())
#                            text.append("%s %s %s HP - %s"%(e[3],e[2],e[6],e.brain.stateName() ))
                            #text.append("%s %s "%(e[3],e[2]))
                            
                             #   text.append("%s %s "%(e[3],e[2]))
                    for o in objects:
                        if o.coordlist() == cursor:
                            text.append("You see a "+object_names(o))

                for _ in range(0,8-len(text)):
                    text.append("")
                text.append("[<^v>] or [hjkl]   to move cursor around")
#                text.append("[Space]            to show path to point")
                text.append("[Tab]              to cycle through creatures/items")
                text.append("[Enter]            to exit examine mode")


                
                draw()
                curc = 0
                addchsafe(cursor[1],cursor[0],'X',color_pair(curc))
                blitback()

                if showpath:
                    if path == -1:
                        text.append("No path found to this point.")
                    else:
                        for po in path:
                            mypad.addch(po[1],po[0],'.',color_pair(0))

                blitlvl()                

                for i in range(0,12):
                    stdscr.addstr(LW_H+3+i,1," "*LW_W)
                    if i < len(text):
                        stdscr.addstr(LW_H+3+i,1,text[i])
                
                

                flush_main()


                s = getchar()

                if s in [KEYUP,ord('k')]:
                    cursor[1]-=1
                elif s in [KEYDOWN,ord('j')]:
                    cursor[1]+=1
                elif s in [KEYLEFT,ord('h')]:
                    cursor[0]-=1
                elif s in [KEYRIGHT,ord('l')]:
                    cursor[0]+=1
                elif s in [ord('\t'),9]:
                    if len(vobj)>0:
                        cursor[0] = vobj[point][0]
                        cursor[1] = vobj[point][1]                    
                        point+=1
                        point%=len(vobj)
                elif s in [ord(' ')] and DEBUG:
                    def blfunc(x,y):
                        return not (fag(x,y) and iswalkable(x,y))
                    path = astar.pathfind(blfunc, (x,y), tuple(cursor))
                    showpath = 1

                elif s in [KEYENTER]:
                    break

                cursor[0] %= LV_W
                cursor[1] %= LV_H

                updateCam(cursor[0],cursor[1])


            updateCam()


            return False


        #d button drop item
        if cmd == ord('d') and (len(inventory)+len(equip))>0:
            stdscr.addstr(7,7,"Select the item you want to drop")
            n = 0
            lawlz = False
            while True:
                for i in range(0,len(inventory)):
                    s = object_names(inventory[i])[:INVCLIP]
                    back.addstr(7+i,LW_W+4, s,color_pair(ssheet[inventory[i][2]][1]))
                for i in range(0,len(equip)):
                    back.addstr(3+i,LW_W+4, object_names(equip[i][0])[:INVCLIP])

                if n < len(equip):
                    back.addstr(3+n,LW_W+4, object_names(equip[n][0])[:INVCLIP], color_pair(9))
                else:
                    s = object_names(inventory[n-len(equip)])[:INVCLIP]
                    back.addstr(7+n-len(equip),LW_W+4, s,color_pair(9))
                blitback()
                blitlvl()
                flush_main()
                s = getchar()

                if s == KEYDOWN:
                    n = (n+1)%(len(inventory)+len(equip))
                elif s == KEYUP:
                    n = (n-1)%(len(inventory)+len(equip))
                elif s == KEYENTER:
                    lawlz = True
                    turn = True
                    break
                else:
                    turn = False
                    break

            it = n
            if lawlz:
                    
                if it>=len(equip):
                    pos = it - len(equip)
                    #special droppings
                    if inventory[pos][2] == OBJ_GNOME:
                        mess("You let "+inventory[pos].gnome.name+" go")
                        gibby = inventory[pos].gnome
                        gibby.brain.status = GN_FULL
                        (gibby.x,gibby.y) = (x,y)
                        entities.append(gibby)
                        del inventory[pos]
                    else: #ordinary droppings (special effects)
                        sbobs=False
                        if inventory[pos].ID == OBJ_STONE:
                            for e in objects:
                                if (e.ID == OBJ_PLANT) and (e.species == 1 ) and (e[0]==x) and (e[1]==y):
                                    sbobs = True
                        mess("You drop the "+object_names(inventory[pos]))
                        if lvl[x][y] == 8:
                            mess("...it is consumed by the lava")
                        else:
                            inventory[pos].x = x
                            inventory[pos].y = y
                            objects.append(inventory[pos])

                        del inventory[pos]

                        if sbobs:
                            mess("The stone breaks the Stramonium")
                            mess("Out comes a litte seed...")
                            objects.append(Item(OBJ_STRAMONIUM_SEED,x,y))
                else: 
                    pos = it
                    mess("You drop the "+object_names(equip[pos][0]))
                    if lvl[x][y] == 8:
                        mess("...it is consumed by the lava")
                    else:
                        equip[pos][0].position(x,y)
                        
                        objects.append(equip[pos][0])
                        del equip[pos]
            return turn
    
        
        #a button pick up objects
        if cmd == ord('a'):
            found=[]
            oc = objects
            MAXAX = 10
            ccc = 0
            for i in range(0,len(oc)):
                o = oc[i]
                if ((o[0] == x) and (o[1] == y)):
                    found.append(i)
                    ccc+=1
                if ccc >= MAXAX:
                    break

            if len(found)==0:
                o = -1
                mess("There is nothing here.")

            elif len(found)==1:
                o = oc[found[0]]
            else:
                z = 0
                while True:
                    h = 5
                    for j in range(0,len(found)):
                        f = found[j]
                        if j == z:
                            c = color_pair(1)
                        else:
                            c = color_pair(0)
                        stdscr.addstr(h,5,object_names(oc[f]),c)
                        h+=1
                    flush_main()
                    fff = getchar()
                    if fff == KEYUP:
                        z = (z-1)%len(found)
                    elif fff == KEYDOWN:
                        z = (z+1)%len(found)
                    elif fff == KEYENTER:
                        break
                    else:
                        return False
                o = oc[found[z]]
            

            if o != -1:
                    if o[2] == OBJ_PUKE:
                        mess("Someone else is going to clean that.")
                        return False
                    elif o[2] == OBJ_CHESTMONSTER:
                        mess("The object explodes in a swarm of enemies",4)
                        w = randint(3,8)
                        koth = []
                        cnt = 0
                        for p in range(0,w):
                            px = x
                            py = y
                            while (not isfreepos(px,py)) and cnt < 500 and (not [px,py] in koth):
                                cnt +=1
                                px += randint(-1,1)
                                py += randint(-1,1)
                                px = max(0, min(px,LV_W-1))
                                py = max(0, min(py,LV_H-1))
                            koth.append([px,py])

                        for j in koth:
                            entities.append(Animal(j[0],j[1],randint(stage//3,stage//2),PR_AGGRESSIVE))
                        objects.remove(o)
                        return True
                    elif o[2] == OBJ_PLANT:
                        if additem(o):
                            mess("You pick up a "+object_names(o))
                            if o.adjective == 1:
                                gloves=0
                                for k in equip:
                                    if k[0][2]==OBJ_GLOVES:
                                        gloves=1
                                if gloves == 0:
                                    hitp(10,True)
                                    mess("You got stung by the herb. -10 HP",4)
                            objects.remove(o)
                            return True
                        else:
                            mess("Your inventory is full",3)
                            return False
                    else:
                        if additem(o):
                            mess("You pick up a "+object_names(o))
                            objects.remove(o)
                            return True
                        else:
                            mess("Your inventory is full",3)
                            return False
        
        #cast spell
        if cmd == ord('c'):
            if mana > 0:
                wand = 0
                for k in equip:
                    if k[0][2]==OBJ_WAND:
                        wand = 1
    
                ccc = [color_pair(n) for n in [6,9,11,1]]
                cck = [color_pair(n) for n in [8,4,3,0]]
                l = 0
                c = 0
                doit = False
                
                #patch = [ [j,i, mypad.inch(j,i) ] for i in range(max(0,x-10),min(LV_W,x+10)) for j in range(max(0,y-10),min(LV_H,y+10))]
                while not doit:
                   # for gag in patch:
                   #     addchsafe(gag[0],gag[1],gag[2],color_pair(0))
                    draw()
                    if l!=3:
                        
                        rw = spellrange(spellbook[l][c][1])
                        if rw > -1: 
                            y0 = max(0,y-rw)
                            y1 = min(LV_H-1,y+rw)
                            x0 = max(0,x-rw)
                            x1 = min(LV_W-1,x+rw)

                            jobs = [ [j,i] for j in [y0,y,y1] for i in [x0,x,x1] ]
                            for jib in jobs:
                                if jib != [y,x]:
                                    addchsafe(jib[0],jib[1],'*',cck[l])

                    blitlvl()                        

                    for p in range(0,10):
                        stdscr.addstr(2+p,LW_W+4,' '*13,0)
                    t = 0
                    for i in range(0,4):
                        if l==i:
                            stdscr.addstr(2,LW_W+4+t,classnames[i].ljust(10),ccc[i])
                            if l!=3:
                            
                                for i in range(0,min(spellsprog[l],len(spellbook[l]))):
                                    if c == i:
                                        sbcol = color_pair(13)
                                    else:
                                        sbcol = cck[l]
                                    stdscr.addstr(3+i,LW_W+4+t,(str(spellbook[l][i][0])+" "+spellbook[l][i][2]).ljust(10),sbcol)
                            t+=10
                        else:
                            stdscr.addch(2,LW_W+4+t,'*',ccc[i]) 
                            t+=1
                    
                    flush_main()
                    lek=getchar()
                    if lek == KEYRIGHT:
                        l = (l+1)%4
                        c = 0
                    if lek == KEYLEFT:
                        l = (l-1)%4
                        c = 0                   
                    if lek == KEYUP and l!=3:
                        c = (c-1)%max(1,min(spellsprog[l],len(spellbook[l])))
                    if lek == KEYDOWN and l!=3:
                        c = (c+1)%max(1,min(spellsprog[l],len(spellbook[l])))

                    if lek == KEYENTER:
                        doit = True

                if (l != 3) and (spellsprog[l]>0):
                    if mana >= spellbook[l][c][0]:
                        spellcast(spellbook[l][c][1])
                        mana -= spellbook[l][c][0]
                        return True
                    else:
                        mess("You don't have the mana for that.",3)
                        return False

                else:
                    return False
                        
            else:
                mess("You don't have any mana to perform magic with",3)
                return False
    
        # u button use object (0-9)
        lawlz = False
        burnit = False
        printinfo = False
#       if cmd  in range(ord('0'),ord('9')+1):
#           lawlz = True    
#           touse = cmd-ord('0')
        if cmd == ord('u') and len(inventory)>0:
            n = 0
            while True:

                blitlvl()
                for i in range(0,len(inventory)):
                    s = object_names(inventory[i])[:INVCLIP]
                    back.addstr(7+i,LW_W+4, s, color_pair(inventory[i].colour()))
                s = object_names(inventory[n])[:INVCLIP]
                back.addstr(7+n,LW_W+4, s,color_pair(6))

                if printinfo:
                    for i in range(0,len(ITINFOBACK)):
                        back.addstr(2+i,2,ITINFOBACK[i],color_pair_fb(WHITE,BLACK))
 

                back.addstr(LW_H,2,  "[Enter] use/equip - [b] burn for torch",color_pair_fb(YELLOW,BLACK))
                back.addstr(LW_H+1,2,"[i] item details",color_pair_fb(YELLOW,BLACK)) 
           
                blitback()
                flush_main()
                s = getchar()

                if s == KEYDOWN:
                    n = (n+1)%len(inventory)
                elif s == KEYUP:
                    n = (n-1)%len(inventory)
                elif s == KEYENTER:
                    lawlz = True
                    touse = n
                    break
                elif s == ord('b'):
                    burnit = True
                    touse = n
                    break
                elif s == ord('i'):
                    printinfo = not printinfo
                else:
                    return False
                    break
    
        if burnit:
            if addburn(inventory[touse]):
                        del inventory[touse]
                        turn = True
            else:
                        turn = False

        if lawlz:
            turn = True
            if touse in range(0,len(inventory)):
                idd = inventory[touse][2]
                if idd == OBJ_LETTER:
                    data = [
",---------------------------------------------.",
"(G|                                           |"] + [
"  |                                           |"]*20 + [
"  | .-------------------------------------------.",
"  l  )                                          )",
"   '=-------------------------------------------'"]

                    data2 = [
    "Dear {0},".format(name),
    "   It has been noted you are a valuable  ",
    "warrior. We thought it would be extremely",
    "nice if you descended through the dark   ",
    "rooms of the deep dungeon of {0}".format(dungeonname),
    "where the dark mage Oskar, escaped from  ",
    "the Royal Prisons, is hiding, and murder ",
    "him. The reward will be conspicuous.     ",
    "",
    "                        His Majesty      "
                    ]

                    yyy=2
                    for l in data:
                        stdscr.addstr(yyy,2,l)
                        yyy+=1
                    yyy=4
                    for l in data2:
                        stdscr.addstr(yyy,6,l)
                        yyy+=2  
                    flush_main()
                    getchar()
                elif idd == OBJ_PAPER:
                    data = clues[inventory[touse].data]                   
                    yyy=2
                    for l in data:
                        stdscr.addstr(yyy,2,l)
                        yyy+=1
       
                    flush_main() 
                    getchar()
                    
                elif idd == OBJ_BREAD:
                    mess("You eat the bread. +25 HP",2)
                    hp = min(mxhp,hp+25)
                    del inventory[touse]
                elif idd == OBJ_GOULASH:
                    mess("You eat the goulash. +50 HP",2)
                    hp = min(mxhp,hp+50)
                    del inventory[touse]
                elif idd == OBJ_PASTA:
                    mess("You eat the pasta. +100 HP",2)
                    hp = min(mxhp,hp+100)
                    del inventory[touse]
                elif idd == OBJ_CARCASS:
                    if randint(0,1)==0:
                        s=inventory[touse].original*2 + randint(0,2)
                        mess("You eat the carcass (+"+str(s)+" HP)",2)
                        hp = min(mxhp,hp+s)
                    else:
                        mess("The meat makes you horribly sick",3)
                        curss[CURS_POISON] += 60 + randint(0,30)
                    del inventory[touse]
                elif idd == OBJ_FAIRY_LIVER:
                    b = randint(40,80)
                    mess("You eat the liver. +"+str(b)+" MANA")
                    mana = min(mana+b,MAXMANA)
                    del inventory[touse]
                elif idd == OBJ_GNOME:
                    l = inventory[touse].gnome.brain.loot 
                    if l == -1:
                        mess("The gnome is not carrying anything")
                    elif l.ID == OBJ_GOLD:
                        mess("You get back your money")
                        gold += l.amount
                    else:
                        mess("You shake the gnome and a "+object_names(l) +" comes out.")
                        inventory[touse].gnome.brain.loot.position(x,y)
                        objects.append(inventory[touse].gnome.brain.loot)

                    inventory[touse].gnome.brain.loot = -1

                elif idd == OBJ_PLANT:
                    species = inventory[touse].species
                    adj = inventory[touse].adjective
                    bonus = 1
                    if adj == 5:
                        bonus = 4
                    elif adj == 4:
                        bonus = 2
                    elif adj == 1:
                        mess("You get stung by the herb (-10 HP)")
                        hitp(10,True)
                    elif adj == 2:
                        mess("This plant is sacred to the gods. +2 MANA")
                        mana=min(mana+2,MAXMANA)
                    elif adj == 3:
                        if curss[CURS_ICE] > 0:
                            mess("The plant unfreezes you")
                        curss[CURS_ICE] = 0
                    
                    if(species == 0):
                        hp = min(mxhp,hp+40*bonus)
                        mess("The herb makes you healthier. (+"+str(40*bonus)+" HP)")
                    elif species == 1:
                        hitp(30*bonus,True)
                        curss[CURS_POISON] = 100*bonus
                        mess("You eat the herb and feel very, very ill...",4)
                    elif species == 2:
                        mana=min(mana+2*bonus,MAXMANA)
                        mess("You eat the Sage. (MANA +"+str(2*bonus)+")")
                    elif species == 3:
                        if randint(0,4)<3:
                            atk+=bonus
                            mess("The herb makes you stronger. (ATK +"+str(bonus)+")")
                        else:
                            mess("You eat the herb, but nothing happens.")
                    elif species == 4:
                        if randint(0,2)==0:
                            dfn+=bonus
                            mess("You feel more resistant. (DEF +"+str(bonus)+")")
                        else:
                            mess("You eat the herb, but nothing happens.")
                    else:
                        mess("You eat the herb, but nothing happens.")
                        
                    del inventory[touse]

                elif idd == OBJ_BOOK_BOTANY:
                    count = 0
                    for p in inventory:
                        if p[2] == OBJ_PLANT:
                            if p.identified == 0:
                                count += 1
                            p.identified = 1
                    mess(str(count)+" plants were identified.")
                    del inventory[touse]
                elif idd == OBJ_BOOK_TELEPORTATION:
                    spellcast(SPELL_TELEPORT)
                    del inventory[touse]
                elif idd == OBJ_BOOK_FIRE:
                    spellcast(SPELL_FIRE)
                    del inventory[touse]
                elif idd == OBJ_BOOK_THUNDER:
                    spellcast(SPELL_THUNDER)
                    del inventory[touse]

                elif idd == OBJ_BOOK_GEOGRAPHY:
                    exx=-1
                    exy=-1
                    for i in range(0,LV_W):
                        for j in range(0,LV_H):
                            if lvl[i][j] == 4:
                                exx=i
                                exy=j
                    if (exx>=0) and (exy>=0):
                        nonon=""
                        if (exx-x>0):
                            nonon+= str(exx-x)+"E " 
                        elif exx-x<0:
                            nonon+= str(x-exx)+"W "

                        if (exy-y>0):
                            nonon+=str(exy-y)+"S"
                        elif (exy-y<0):
                            nonon+=str(y-exy)+"N"
                        
                        mess("Exit is "+nonon+" from you.")
                    else:
                        mess("There is no exit...")
                    del inventory[touse]

                elif idd == OBJ_BOOK_TRANSMIGRATION:
                    spellcast(SPELL_TRANSMIGRATION)
                    del inventory[touse]                        
                elif idd == OBJ_BOOK_CLAIRVOYANCE:
                    spellcast(SPELL_WATCH)
                    del inventory[touse]
                elif idd == OBJ_BOOK_WINTER:
                    spellcast(SPELL_WINTER)
                    del inventory[touse]

#                elif idd == OBJ_SULFUR:
                   

                elif idd == OBJ_HANDBOOK:
                
                    jobby=False
                    c = 0
                    while not jobby:
                        stdscr.addstr(0,2,"CHOOSE CATEGORY",color_pair(10))
                        for i in range(0,3):
                            if c == i:
                                cil = color_pair(11)
                            else:
                                cil = color_pair(0)
                            if spellsprog[i]>=len(spellbook[i]):
                                gigga = " no more spells."
                            else:
                                gigga = " " + spellbook[i][spellsprog[i]][2]
                            stdscr.addstr(3+i,3,classnames[i] + gigga,cil)
                        flush_main()
                        q = getchar()
                        if q == KEYDOWN:
                            c = (c+1)%3
                        if q == KEYUP:
                            c = (c-1)%3
                        if q == KEYENTER:
                            jobby = True
                    spellsprog[c] += 1
                    mess("You learn a new spell.")

                    del inventory[touse]
         

                elif idd in range(200,300):
                    if len(equip) < 3:
                        mess("You equip the "+object_names(inventory[touse]))
                        equip.append([inventory[touse],100])
                        del inventory[touse]
                    else:
                        mess("You can't equip any more items")

                else:
                    turn = False
                    mess("You cannot use that.")
            else:
                turn = False
                mess("That slot is empty")
            return turn

        #z button sort inventory
        if cmd == ord('z'):
            mess("You sort your inventory")
            inventory.sort(key = lambda object: object_names(object).lower() )
            return False

        #q button see history
        if cmd == ord('q'):
            p = len(messages)-24
            while True:
                stdscr.clear()
                yy = 1
                for m in messages[max(0,p) : min(len(messages),p+24) ] :
                    stdscr.addstr(yy,1,m[0],color_pair(m[1]))
                    yy+=1
                flush_main()
                qeqr = getchar()
                if qeqr in [KEYDOWN,ord('j')]:
                    p = min(len(messages)-24,p+1)
                if qeqr in [KEYUP,ord('k')]:
                    p = max(0,(p-1))
                if qeqr in [KEYLEFT,ord('h')]:
                    p = max(0,(p-10))
                if qeqr in [KEYRIGHT,ord('l')]:
                    p = min(len(messages)-24,p+10)
                if qeqr in [KEYENTER,ord('q')]:
                    break    
            return False
                
            

        #i button (stats screen) i panel
        if cmd == ord('i'):
            stdscr.clear()

            for i in range(1,50):
                stdscr.addch(2,i,".")

            
            sss = ", water will enter dungeon in "+str(abs(waterlvl-WATSTEPS)) + " turns."          
            if waterfrozen:
                sss = ", water is frozen."
            sad = ""

            if (waterlvl//WATSTEPS)>0:
                sad = " (next in "+str(WATSTEPS - waterlvl%WATSTEPS) + " turns.)"
                sss = ", water at floor "+str(waterlvl//WATSTEPS) + sad
                if waterfrozen:
                    sss = ", water is frozen."
                for i in range(1,waterlvl//WATSTEPS+1):
                    if waterfrozen:
                        stdscr.addch(2,i,"/",color_pair(15))
                    else:
                        stdscr.addch(2,i,"~",color_pair(6))


            stdscr.addstr(1,1,"Floor: "+str(stage).zfill(2) + "/50"+sss)
            if (waterlvl//WATSTEPS>=stage):  
                stdscr.addch(2,stage,"@",color_pair(6))
            else:
                stdscr.addch(2,stage,"@")

            lc = color_pair(2) #5

            stdscr.addstr(4,1," "*30,lc)
            stdscr.addstr(4,1,"EMERALDS",lc)
            for i in range(0,7):
                for j in range(0,7):
                    if gems[j*7+i]:
                        stdscr.addch(6+j,2+i,'*',color_pair(2))
                    else:
                        stdscr.addch(6+j,2+i,'.')

            stdscr.addstr(4,15,"EXP "+str(exp)+"/"+str(exprofile(rank)), color_pair(3))
            stdscr.addstr(6,14,"(          )")
            n = exp*10//exprofile(rank)  
            stdscr.addstr(6,15," "*n,color_pair(6))

            stdscr.addstr(8,15,"SPELLBOOK",color_pair_fb(MAGENTA,BLACK))
            for i in range(0,3):
                for j in range(0,len(spellbook[i])):
                    if j < min(spellsprog[i],len(spellbook[i])):
                        ccceee = color_pair(0)
                    else:
                        ccceee = color_pair(4)
                    stdscr.addstr(10+j,15 + 4*i, spellbook[i][j][2][:3].upper(),ccceee)
    
            '''stdscr.addstr(4,30, "ORIENTATION")
    
            sttx = 31
            stty = 10
            for i in range(0,5):
                for j in range(0,5):
                    if(i+j<=4):
                        c=(' ',C_WHITE)
                        if (i==0) and (j==0):
                            c=(' ',C_WHITERED)
                        if (i==4) and (j==0):
                            c=(' ',C_WHITEYELLOW)
                        if (i==0) and (j==4):
                            c=(' ',C_WHITEBLUE)
                        if (i+j == 1):
                            c=('%',C_WHITERED)
                        if (i==3):
                            c=('%',C_WHITEYELLOW)
                        if (j==3):
                            c=('%',C_WHITEBLUE)
                        if ([i,j]==orientation):
                            c = ('@',color_pair(0))'''


                            
            stdscr.addstr(4,31,"CURSES",color_pair(4))
            if sum(curss) == 0:
                stdscr.addstr(6,31,"You are fine.")
            else:
                t = 0
                for c in range(0,len(curss)):
                    if curss[c] > 0:
                        stdscr.addstr(6+t,31,curses_names[c]+" ("+str(curss[c])+")")
                        t+=1
            


            stdscr.addstr(15,1,"ATTRIBUTES",color_pair_fb(CYAN,BLACK))
            u = 0
            for j in range(0,len(attributes)):
                if attributes[j]:
                    stdscr.addstr(17+u,1,attribute_strings[j][0])
                    u+=1

            flush_main()
            getchar()
            return False

        #? button o button
        if cmd in [ord('?'),ord('o')]:
            stdscr.clear()
            for i in range(0,len(helppanel)):
                stdscr.addstr(i,0,helppanel[i])
            flush_main()
            getchar()
            return False   

        #skip turn s button
        if cmd == ord('s'):
            mess("You skip a turn.")
            return True

        #suicide
        if cmd == ord('p'):
            stdscr.addstr(7,7,"Are you sure you want to kill yourself? (Y/N)")
            flush_main()
            sure = getchar()
            if (sure in [ord('y'),ord('Y')]):
                mess("You commit suicide.")
                crawlin=False
                alive=False
            return True

        #toggle dots toggle visibility toggle fov toggle
        if cmd == ord('v'):
            visibility_dots = not visibility_dots
            return False

        #DEBUG COMMANDS 
        #next level
        #mana cheat
        if DEBUG:
            if cmd == ord('n'):
                crawlin=False
                return True
            if cmd == ord('m'):
                gold=999
                mana=999
                givexp(500)
            if cmd == ord('.'):
                for i in range(0,len(gems)):
                    gems[i] = True
            if cmd == ord(','):
                stage=34
                crawlin=False
            return False

        return turn

def do_timestep():
        global x,y,hp,mxhp,gold,mana,lvl,entities,ssheet,tset,objects,inventory,equip,waterlvl,atk,dfn,stage,rank,attributes,alive,crawlin,visibility_dots,camx,camy,fovBrain,waterfrozen,waterlvl,manacount,hallucinatinganimals,freezinganimals
        #move wotah
        if not waterfrozen:
            waterlvl+=1
            if stage - waterlvl//WATSTEPS >= 3:
                waterlvl+=2
            if waterlvl==WATSTEPS*stage:
                mess("You hear water entering the dungeon...")
            if waterlvl//WATSTEPS>=stage:
                if waterlvl%15==0:
                    (xw,yw) = findfree()
                    lvl[xw][yw] = 100
                if waterlvl%10==0:
                    for i in range(0,LV_W):
                        for j in range(0,LV_H):
                            if lvl[i][j]==100:
                                for z in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:
                                    if iswalkable(z[0],z[1]):
                                        lvl[z[0]][z[1]] = 99
                    for i in range(0,LV_W):
                        for j in range(0,LV_H):
                            if lvl[i][j]==99:
                                lvl[i][j]=100
    
        #move entities

        compileWmap()

        for e in entities:
            
                if ord(e[3]) in range(ord('a'),ord('z')+1):
                    if randint(0,25) > ord(e[3]) - ord('a'):
                        reps = 1
                    else:
                        reps = 2
                elif e[3] == 'D':
                    reps = 1
                else:
                    reps = 2


                

                for lol in range(0,reps):
                    ex=e[0]
                    ey=e[1]

                    if not isinstance(e,list):
                        e.brain.doStep()


                        


                    '''if ((abs(ex-x)+abs(ey-y)) < 8) :
                        


                        if (abs(ex-x)+abs(ey-y)) == 1:
                            led=hitp(e[4])
                            if led>0:
                                if randint(0,1) == 0:
                                    mess("The "+e[2]+" hits you. (-"+str(led)+" HP)",4)
                                else:
                                    mess("The "+e[2]+" strikes you. (-"+str(led)+" HP)",4)
                                if e[3] in freezinganimals:
                                    if randint(0,10)==0:
                                        curss[CURS_ICE] = randint(5,10)
                                        mess("The "+e[2]+" has frozen you",4)
                                if e[3] in hallucinatinganimals:
                                    if randint(0,10)==0:
                                        curss[CURS_HALLUCINATION] = randint(2,20)
                                        mess("You start hallucinating",4)
                            else:
                                mess("The "+e[2]+" misses.")

                            if e[3] == 'S':
                                if (not gender) and curss[CURS_LOVE] == 0:
                                    mess("You get in love with the Succubus")
                                curss[CURS_LOVE] = 10

                            

                            if (len(equip)>0) and (randint(0,30*(1+attributes[ATTR_STRONG_HANDS])) == 0):
                                q = randint(0,len(equip)-1)
                                mess("The "+e[2]+" has stripped you of your "+object_names(equip[q][0])+"!")
                                del equip[q]
                            possible=[]
                        else:
                            if cansee(x,y,ex,ey):
                                factx=-sgn(ex-x)
                                facty=-sgn(ey-y)
                                possible=[[ex,ey+facty],[ex+factx,ey]]
                            else:
                                possible=[[ex,ey-1],[ex,ey+1],[ex-1,ey],[ex+1,ey]]
                    else:
                        possible=[[ex,ey-1],[ex,ey+1],[ex-1,ey],[ex+1,ey]]
    
            #if e[2] == "Dragon":
            #   possible+=[[ex+i,ey+j] for i in (-1,1) for j in (-1,1)]
            #   possiblec=possible
            #   for p in possiblec:
            #       if ((p[0]-e[8])**2 + (p[1]-e[9])**2) > 5:
            #           possible.remove(p)
                    possiblec=possible
                    for p in possiblec:
                        if not iswalkable(p[0],p[1]):
                            possible.remove(p)
                    if len(possible)>0:
                        (nx,ny)=choice(possible)
                        if iswalkable(nx,ny):
                            (e[0],e[1])=(nx,ny)   '''
        #mana grow
        if mana>0:
            manacount+=1
            if manacount%1000 == 0:
                mana = min(mana+ 1 + mana//50,MAXMANA)

        #cure curses
        if curss[CURS_TELEPORT] == 1:
            (x,y)=findfree()
            mess("You teleport somewhere else")
            updateCam()

        if curss[CURS_ICE] == 1:
            mess("You are unfrozen.",2)

        for i in range(0,len(curss)):
            curss[i]= max(0,curss[i]-1)


        

        #consume torch
        if len(torch)>0 and toggletorch:
            torch[-1][1] -= 1
            if torch[-1][1] <= 0:
                del torch[-1]
            if len(torch) == 0:
                mess("Your torch burns out. You are engulfed by darkness.",4)

        #extend fog
        
        if False:
            floodfill(x,y)
            floodfill(x+1,y)
            floodfill(x-1,y)
            floodfill(x,y-1)
            floodfill(x,y+1)
        #for i in range(max(0,x-4),min(LV_W,x+4)):
        #   for j in range(max(0,y-4),min(LV_H,y+4)):
        #       fog[i][j] = 1
        
        
        #check for death
        if(hp<=0):
            alive=False

   

def do_step():
        global x,y,hp,mxhp,gold,mana,lvl,entities,ssheet,tset,objects,inventory,equip,waterlvl,atk,dfn,stage,rank,attributes,alive,crawlin,visibility_dots,camx,camy,fovBrain,waterfrozen,waterlvl,manacount

   
        #checkobjcollision
        oc = objects
        for o in oc:
            if ((o[0] == x) and (o[1]==y)):
                if o[2] == OBJ_GOLD:
                    gold+=1
                    mess("You find a gold nugget")
                    objects.remove(o) 
                if o[2] == OBJ_DROP:
                    gain = randint(1,2)
                    if attributes[ATTR_PIOUS]:
                        gain = 2
                    mana=min(mana+gain,MAXMANA)
                    mess("You drink a mana drop (+"+str(gain)+")")
                    objects.remove(o)
                if o[2] == OBJ_EMERALD:
                    gems[stage-1] = True
                    mess("You find an emerald")
                    objects.remove(o) 

        #deal damage
        if lvl[x][y] == 8:
            scales=False
            for s in equip:
                if s[0][2] == OBJ_DRAGON_SCALES:
                    scales = True

            if not scales:
                dmg = int(max(mxhp*0.08,5))
                if attributes[ATTR_DRAGONBORN]:
                    dmg = dmg//2
                mess("You walk on lava (-"+str(dmg)+" HP)")
                hitp(dmg,True)


def do_prelim():
    global clairvoying
    #end clairvoying (it can't be forever, y'know?)
    clairvoying = max(0,clairvoying-1)



stdscr.clear()
flush_main()

if DEBUG:
    spellsprog = [9]*3

alive=True
stage=0
WATSTEPS=600
waterlvl=-300
#preliminary positioning (for functions)
x=-1
y=-1
clairvoying=0
visibility_dots=True
if "vdots" in options:
    visibility_dots = int(options["vdots"])
fovBrain = Map()
while alive:
    if waterfrozen:
        waterfrozen=False
        mess("The ice melts...")
    stage+=1
        
    objects = []
    entities = []

    if stage<50:
        #LEVEL GENERATION


        #try generation
        trygen = True
        trycount = 0
        reasons = []
        while trygen:
    
            mapper=dMap()
            stdscr.clear()
            stdscr.addstr(3,3,"Generating dungeon..." + (trycount>=1)*(" ("+str(trycount)+")"))
            asfd = 5
            reasons = reasons[-5:]
            for r in reasons:
                stdscr.addstr(asfd,3,r)
                asfd += 1
            flush_main()

            reasons = []

            dragonfactor = 2 * (stage**2)//(50**2)
            if DEBUG and stage==1:
                dragonfactor = 2
            
            if stage % 5 != 0:
                dtype = 0 
                lestries = 0
                while not mapper.makeMap(LV_W,LV_H,110,10+dragonfactor,dragonfactor,60):
                    lestries+=1
                lvl = [[converter[mapper.mapArr[j][i]] for i in range(0,LV_W)] for j in range(0,LV_H)]
            else:
                dtype = 1
                mapper.makeVillage(60,60)
                lvl = [[converter2[mapper.caveArr[j][i]] for i in range(0,LV_W)] for j in range(0,LV_H)]
            
            #correct naked edges
            for i in range(LV_W):
                for j in range(LV_H):
                    if lvl[i][j] == 2:
                        shit = False
                        for a in range(max(0,i-1),1+min(LV_W-1,i+1)):
                            for b in range(max(0,j-1),1+min(LV_H-1,j+1)):
                                if ispathable(lvl[a][b]):
                                    shit = True
                                    break   
                            if shit:
                                break
                        if shit:
                            if DEBUG:
                                mess("Corrected naked edge")
                            lvl[i][j] = 1

            #CHECKING

            trygen = False

            trycount += 1

            #count spaces
            spcount = 0
            for l in lvl:
                for j in l:
                    if j == 0:
                        spcount+=1
            if DEBUG:
                mess(str(spcount)+" free spaces")   

            if spcount < 700:
                trygen = True
                reasons.append("Dungeon was too small.")    
        
            #check connectedness
            con = [ [ 0 for y in range(0,LV_H)] for x in range(0,LV_W)]
            (gx,gy) = findfree()
            confloodfill(gx,gy)
            for i in range(0,LV_W):
                find = False
                for j in range(0,LV_H):
                    if lvl[i][j] == 0 and con[i][j] == 0:
                        trygen = True
                        reasons.append("Dungeon was not connected.")
                        if DEBUG:
                            mess("Dungeon unconnected")
                        find = True
                        break
                if find:
                    break

        #correct doors
        sas = [1,3,5,11,12]
        for i in range(1,LV_W-1):
            for j in range(1,LV_H-1):
                if lvl[i][j] == 3:
                    '''c = (lvl[i+1][j] in sas)+(lvl[i-1][j] in sas)+(lvl[i][j-1] in sas)+(lvl[i][j+1] in sas)
                    if c<2:
                        lvl[i][j] = 0'''
                    SBDEN = [(0,-1), (0,+1) , (-1,0) , (+1,0)  ]
                    configuration = [iswall(i+a,j+b) and(lvl[i+a][j+b]!=3) for (a,b) in SBDEN ]
                    if not configuration in DCLUT:
                        lvl[i][j] = 0
                        if DEBUG:
                            mess("Corrected door.")
                    else:
                        if DEBUG:
                            mess("Door cool!")
        
        #add lava
        if stage >= 35:
            if stage >= 40:
                mapper.gayLava(LV_W,LV_H,0.65,30,6)
            else:
                mapper.gayLava(LV_W,LV_H,0.95,30,6)
        
            for i in range(0,LV_W):
                for j in range(0,LV_H):
                    if lvl[i][j] == 0 and mapper.lavaArr[i][j] == 1:
                        lvl[i][j] = 8


        #add exit
        if stage < 50:
            (ex,ey) = findfree()
            lvl[ex][ey] = 4 
        else:
            mess("You enter the last dungeon...")

        #add vending machine
        if stage > 6:
            if randint(0,3)<3:
                mx=randint(0,LV_W-1)
                my=randint(0,LV_H-1)
                s=False
                security=0
                while ((lvl[mx][my]!=1) or (not s)) and security<3000:
                    security += 1
                    mx = randint(0,LV_W-1)
                    my = randint(0,LV_H-1)
                    s = False
                    s = isfreepos(mx+1,my) or isfreepos(mx-1,my) or isfreepos(mx,my-1) or isfreepos(mx,my+1)

                if security<3000:
                    lvl[mx][my] = 7

        #vending machine stats

        
        shuffle(catalogue)

        vmachset = catalogue[:randint(1,4)]

        vmachword = choice([
            ("Sacred to the old gods and th","e new!"),
            ("The Walmart of fairy-slayers!",""),
            ("Thaknar's (TM) denies all res","ponsibility for permadeath."),
            ("*Cough* sdnufer oN. *Cough*  ",""),
            ("You're the chosen one. In unr","elated news, we get rich."),
            ("100% organic dungeon supplies","made w/ genuine dwarf slaves"),
            ("blablabla some crap about qua","lity and customer service"),
            ("Oskar is not what they make h","im look like. He's worse!"),
            ("Murder Aradach! Oh wait, you ","are the other guy. Hah."),
            ("Does the King shop at Naderk?","I thought so."),
            ("A litte tip: the King is just","in LOVE with emeralds."),
            ("Spider Goddesses: worse than","Hitler. We hate those."),
            ("Who has 8 legs and is a God?","Nobody! AHAHAHAHAHAHAHA")
            
        ])
    
        stdscr.addstr(3,3,"Adding objects and entities...")
        flush_main()

        #add 15 gold pieces
        for c in range(0,15):
            (gx,gy) = findfree()
            objects.append(Item(OBJ_GOLD,gx,gy))

        #add 0-2 mana drops
        for c in range(0,2):
            (gx,gy) = findfree()
            objects.append(Item(OBJ_DROP,gx,gy))

        #add 1 emerald
        for c in range(0,1):
            (gx,gy) = findfree()
            objects.append(Item(OBJ_EMERALD,gx,gy))
    
        #add food
        for c in range(0,randint(0,2)):
            (gx,gy) = findfree()
            objects.append(Item(OBJ_BREAD,gx,gy))
        if stage > 5:
            for c in range(0,randint(0,1+min(1,stage//14))):
                (gx,gy) = findfree()
                objects.append(Item(OBJ_GOULASH,gx,gy))
        if stage > 27:
            for c in range(0,randint(0,2)):
                (gx,gy) = findfree()
                objects.append(Item(OBJ_PASTA,gx,gy))
    
        #add plants
        if stage < 25:
            totpla = 4
        else:
            totpla = 1
        for c in range(0,randint(1,totpla)):
            gx = 0
            gy = 0
            while not isfree(lvl[gx][gy]):
                gx = randint(0,LV_W-1)
                gy = randint(0,LV_H-1)
            s = ranplant()
            s.position(gx,gy)
            objects.append(s)

        #add books
        for c in range(0,randint(0,8)):
            (gx,gy) = findfree()
            objects.append(Item(randint(100,MAXBOOK),gx,gy))

        #add handboooks
        if randint(0,7) == 0:
            (gx,gy) = findfree()
            objects.append(Item(OBJ_HANDBOOK,gx,gy))

        #add armour
        for c in range(0,randint(0,3+stage//3)):
            (gx,gy) = findfree()
            objects.append(Item(randint(200,MAXARMOUR),gx,gy))

        for c in range(0,randint(0,stage//25)):
            (gx,gy) = findfree()
            objects.append(Item(randint(250,MAXGOLDEN),gx,gy))

        #add stone
        if randint(0,4)<=1:
            (gx,gy) = findfree()
            objects.append(Item(OBJ_STONE,gx,gy))

        #add sulfur
        if stage in range(3,16)+range(25,30):
            (gx,gy) = findfree()
            objects.append(Item(OBJ_SULFUR,gx,gy))

        #add mobs
        '''for c in range(0,15+stage//5):
            (gx,gy) = findfree()
            i = randint(min(max(0,stage//2-4-2*(i//20)),len(mobs)-1),min(stage//2,len(mobs)-1))
#            entities.append([gx,gy]+list(mobs[i]))
            entities.append( Animal(gx,gy,i,randint(0,2)) )'''

        for _ in range(4+stage//20+randint(-1,1)):
            (gx,gy) = findfree()
            i = randint(min(max(0,stage//2-4-2*(i//20)),len(mobs)-1),min(stage//2,len(mobs)-1))
            add_pack(i,gx,gy,1,2+stage//20)

        #add bosses
        #add dragon
        for i in range(0,LV_W):
            for j in range(0,LV_H):
                if lvl[i][j] == 6:
                    entities.append(Dragon(i,j))
                    lvl[i][j] = 0
        for c in range(0,0*DEBUG*10):
            (gx,gy) = findfree()
            entities.append(Dragon(gx,gy))

        #add fairy
        if DEBUG or (stage > 3) and randint(0,16)==0:
            for _ in range(1+0*DEBUG*10):
                (gx,gy) = findfree()
                entities.append(Fairy(gx,gy))

        #add chestmonster
        for c in range(0,randint(0,2)//2 + DEBUG * 0):
            (gx,gy) = findfree()
            t = choice(list(set(ssheet) - set([OBJ_GOLD,OBJ_PUKE,OBJ_EMERALD,OBJ_DROP,OBJ_CARCASS,OBJ_PLANT,OBJ_CHESTMONSTER,OBJ_GNOME])))  
            objects.append(Chestmonster(t,gx,gy))

        #add succubus
        if (stage in range(18,21)):
            (gx,gy) = findfree()
            entities.append(Succubus(gx,gy))
        
        if stage >= 43:
            for c in range(0,4):
                (gx,gy) = findfree()
                entities.append(Succubus(gx,gy))
        
        #add ice trolls
        if stage in range(30,33):
            (gx,gy) = findfree()
            entities.append(IceTroll(gx,gy))

        #add gnomes
        #for c in range(0,10):
        #   (gx,gy) = findfree()
        if stage > 2:
            for i in range(0,LV_W):
                for j in range(0,LV_H):
                    gnomedens = (dtype==0)*400 + (dtype==1)*50
                    if lvl[i][j] == 11 and randint(0,gnomedens) == 0:
                        entities.append(Gnome(i,j))


        #add clues
        for c in range(0,0):
            if randint(0,16)==0:
                (gx,gy) = findfree()
                objects.append(Clue(randint(0,len(clues)-1),gx,gy))

        #position player
    
        x = LV_W//2
        y = LV_H//2
        while not isfree(lvl[x][y]):
            x = randint(0,LV_W-1)
            y = randint(0,LV_H-1)


    else:
        dtype = 2
        lvl = [[2 for i in range(0,LV_W)] for j in range(0,LV_H)]
        f=open("final",'r')
        flvl = f.readlines()

        for j in range(0,len(flvl)):
            for i in range(0,len(flvl[j])):
                if flvl[j][i] == '#':
                    lvl[i][j] = 1
                if flvl[j][i] == '@':
                    lvl[i][j] = 0
                    x = i
                    y = j
                if flvl[j][i] == '=':
                    lvl[i][j] = 3
                if flvl[j][i] == '*':
                    lvl[i][j] = 10
                if flvl[j][i] == '.':
                    lvl[i][j] = 2
                if flvl[j][i] == ' ':
                    lvl[i][j] = 0
                if flvl[j][i] == 'O':
                    lvl[i][j] = 101 
                        
        f.close()



        mess("NOTE: The final level is under construction :(")
        mess("Thanks for sticking with us till now")



    updateCam()

    fog = [[0 for j in range(0,LV_H)] for i in range(0,LV_W)]

    #floodfill(x,y)
    
#   for i in range(max(0,x-8),min(LV_W,x+8)):
#       for j in range(max(0,y-8),min(LV_H,y+8)):
#           fog[i][j] = 1
    
    stdscr.clear()
    flush_main()

    crawlin=True
    while alive and crawlin:
        
        #available turns
        turns = 1 + (randint(0,100)<speed)

        for _ in range(turns):
            #1 PLAYER TURN
            do_prelim()
            cango=False
            while not cango:
                draw()
                flush_main()
                cmd = getchar()
                cango = dopturn(cmd)
 
            turns-=1
            do_step()

            #exit turn loop if dead or outside level
            if not crawlin or not alive:
                break

            #camera

            updateCam()

        #do step
        do_timestep()

            
    
    
    
stdscr.clear()
flush_main()

if specialending <=1:
    if DEBUG:
        stdscr.addstr(3,5,"This game was in DEBUG MODE",color_pair(10))
    stdscr.addstr(2,15,"You are dead.")
    stdscr.addstr(5,5,"Last messages:")
    ppp=7
    for m in reversed(messages[-5:]):
        stdscr.addstr(ppp,8,m[0])
        ppp+=1

    stdscr.addstr(13,5,"You made it to floor "+str(stage)+" with "+str(sum(gems))+" emeralds.")

if specialending == 2:
    stdscr.addstr(7,16,"You live.")

flush_main()

c = 0
while not (c in [KEYENTER,ord(' ')]):
    c = getchar()

#END
if GRAPHIC:
    1
else:
    curses.nocbreak()
    stdscr.keypad(0)
    curses.echo()
    curses.endwin()

#print resume

if False:
    print("THIS GAME WAS IN DEBUG MODE AND A PLAYER SHEET WILL NOT BE PRODUCED.")
else:
    dname = dungeonname #choice ( [ "Ala", "Seth", "More", "Dath", "Kathra"]) + choice ( [ "go", "na" , "ka", "gu", "ni"]) + choice ( [ "r", "r", "dor"])
    print("")
    print("        _|  |_        ")
    print("       |_ >< _|       ")
    print("+-----*__|  |__*-----+")
    print("Here lies "+name+ " (ID: "+str(ID)+")")
    print("explorer of The Dungeon of "+dname+", slayer of "+str(slaindragons)+" dragons,")
    print("")
    if specialending<=0:
        print("died on floor "+str(stage) + " (may the Gods be with him)")
        print("fighting for His Majesty the King.")
    elif specialending==1:
        print("executed for treason according to the law.")
    elif specialending==2:
        print("he blessed the King with the gift of "+str(sum(gems))+" emeralds")
        print("and lived happily until old age.")
    print("")
    print(("His"*(not gender) + gender *"Her")+" belongings included:")
    for i in inventory:
        print("-"+object_names(i))
    for i in equip:
        print("-"+object_names(i[0]))
    print("")
    print("...and "+str(gold)+" gold pieces" + (specialending!=2)*(", and "+str(sum(gems))+" of the holy emeralds."))
    print("")
    print("He was a good man."*(not gender) + gender*"She was a good woman.")
    print("")
    print("+-----+ H O L E +----+")
    print("")











'''             leng=min(5+2*wand,mana)
                stdscr.addstr(7,7,"+-CAST SPELL-+")
                stdscr.addstr(8,7,"*" + (12-leng)/2*" " +leng*"_"  + (13-leng)/2*" "+"*")
                stdscr.addstr(9,7,"+------------+")
                flush_main()
                c = 0
                s = ""
                while c!= ord('\n') and len(s)<leng:
                    c=getchar()
                    if c>250:
                        c=0
                    if chr(c) in ['q','w','e','r']:
                        s+=chr(c)
                        stdscr.addstr(8,8+ (12-leng)/2,s)
                        flush_main()

                mana= max(0,mana - len(s))
                mess("You cast the spell '"+s+"' (-"+str(len(s))+" MANA)")
                found=False
                if s.find("eqqr") != -1:
                    found = True
                    spellcast(SPELL_FIRE)
                if s.find("ewq") != -1:
                    found = True
                    spellcast(SPELL_TELEPORT)
                if (s.find("wwq") != -1)  or (s.find("qqq") != -1) or (s.find("eqe") != -1) or (s.find("rrw") != -1):
                    found = True
                    spellcast(SPELL_SUICIDE)
                if s.find("ww") != -1:
                    found = True
                    spellcast(SPELL_HEAL)
                if s.find("qeeeq") != -1:
                    found = True
                    spellcast(SPELL_GOLDEN)
                if s.find("qeqr") != -1:
                    found = True
                    spellcast(SPELL_WATCH)
                if s.find("qrw") != -1:
                    found = True
                    spellcast(SPELL_SHOCKWAVE)
                if s.find("rwe") != -1:
                                        found = True
                                        spellcast(SPELL_THUNDER)
                if s.find("req") != -1:
                    found = True
                    spellcast(SPELL_TRANSMIGRATION)
                if s.find("rqrrewr") != -1:
                    found = True
                    spellcast(SPELL_WINTER)
    
                
                if not found:
                    mess("...however, it has no effect.")'''

